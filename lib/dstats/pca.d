/**
This module does a small but growing amount of stuff related to principal
component analysis.  It's a work in progress and experimental.

References:
http://en.wikipedia.org/wiki/Principal_component_analysis#Computing_principal_components_with_expectation_maximization

Author:  David Simcha
*/

/*
 * License:
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
module dstats.pca;

import std.range, dstats.base, dstats.alloc, std.numeric, std.stdio, std.math,
    std.algorithm, std.array, dstats.summary, dstats.random, std.conv,
    std.exception, dstats.regress, std.traits;

/// Result holder
struct PrincipalComponent {
    /// The projection of the data onto the first principal component.
    double[] x;

    /// The vector representing the first principal component.
    double[] rotation;
}

/**
Uses expectation-maximization to compute the first principal component.
This algorithm can be used along with removeComponent() to compute
the first few principal components.  However, it's a bad idea to use it
to compute more than a few principal components because for these use cases
there are more efficient and numerically stable algorithms.  dataIn must be
a rectangular range of ranges representing your data.  buf is an optional
PrincipalComponent struct whose memory will be recycled for returning the
output if possible.

Note that dataIn is copied, so column normalization will not be reflected in it.
*/
PrincipalComponent firstComponent(Ror)(Ror dataIn,
PrincipalComponent buf = PrincipalComponent.init) {
    mixin(newFrame);

    // Convert the matrix to a double[][].
    static double[] doubleTempdup(R)(R range) {
        return tempdup(map!(to!double)(range));
    }

    auto data = tempdup(
        map!doubleTempdup(dataIn)
    );

    if(data.empty) {
        return PrincipalComponent.init;
    }

    normalizeColumns(data);
    return firstComponentNormalized(data, buf);
}

/**
Finds the first principal component assuming that the column means are already
zero, this avoiding duplicating the data.  Since this is an efficiency hack,
it also doesn't bother checking for rectangularness.
*/
PrincipalComponent firstComponentNormalized(Ror)(Ror data,
PrincipalComponent buf = PrincipalComponent.init) {
    mixin(newFrame);

    if(data.empty) return typeof(return).init;
    immutable rowLen = data.front.length;
    immutable colLen = walkLength(data.save);

    auto t = newStack!double(rowLen);
    auto p = (buf.rotation.length >= rowLen) ?
              buf.rotation[0..rowLen] : new double[rowLen];
    p[] = 1;

    static bool approxEqualOrNotFinite(const double[] a, const double[] b) {
        foreach(i; 0..a.length) {
            if(!isFinite(a[i]) || !isFinite(b[i])) {
                return true;
            } else if(!approxEqual(a[i], b[i], 1e-3, 1e-6)) {
                return false;
            }
        }

        return true;
    }

    while(true) {
        t[] = 0;
        foreach(row; data.save) {
            immutable dp = dotProduct(p, row);
            static if( is(typeof(row) : const(double)[] )) {
                // Use array op optimization if possible.
                t[] += row[] * dp;
            } else {
                size_t i = 0;
                foreach(elem; row.save) {
                    t[i++] += elem * dp;
                }
            }
        }

        immutable tMagnitude = magnitude(t);
        t[] /= tMagnitude;

        if(approxEqualOrNotFinite(t, p)) {
            p[] = t[];
            break;
        }

        p[] = t[];
    }

    auto x = (buf.x.length >= colLen) ?
              buf.x[0..colLen] : new double[colLen];
    size_t i = 0;
    foreach(row; data) {
        x[i++] = dotProduct(p, row);
    }
    x[] -= mean(x).mean;

    return PrincipalComponent(x, p);
}

/**
Normalize a matrix such that each row has a mean of 0.  Throws DstatsException
if matrix is not rectangular.
*/
void normalizeColumns(Ror)(Ror data) {
    if(data.empty) {
        return;
    }

    mixin(newFrame);
    immutable rowLen = data.front.length;

    auto means = newStack!Mean(rowLen);
    means[] = Mean.init;
    foreach(row; data) {
        size_t i = 0;
        foreach(elem; row) {
            enforce(i < rowLen, "Matrix must be rectangular for PCA.");
            means[i++].put(elem);
        }

        enforce(i == rowLen, "Matrix must be rectangular for PCA.");
    }

    foreach(row; data) {
        size_t i = 0;
        foreach(ref elem; row) {
            elem -= means[i++].mean;
        }
    }
}

/**
Remove the principal component specified by the given rotation vector from
data.  data must have assignable elements.
*/
void removeComponent(Ror, R)(Ror data, R rotation) {
    double[2] regressBuf;

    immutable rotMagNeg1 = 1.0 / magnitude(rotation);
    foreach(row; data) {
        immutable dotProd = dotProduct(rotation, row);
        immutable coeff = dotProd * rotMagNeg1;

        auto rs = row.save;
        auto rots = rotation.save;
        while(!rs.empty && !rots.empty) {
            scope(exit) {
                rs.popFront();
                rots.popFront();
            }

            rs.front = rs.front - rots.front * coeff;
        }
    }
}

private double magnitude(R)(R x) {
    return sqrt(reduce!"a + b * b"(0.0, x));
}

version(unittest) {
    // There are two equally valid answers for PCA that differ only by sign.
    // This tests whether one of them matches the test value.
    bool plusMinusAe(T, U)(T lhs, U rhs) {
        return approxEqual(lhs, rhs) || approxEqual(lhs, map!"-a"(rhs));
    }
    void main() {}

}

unittest {
    // Values from R.

    double[][] mat = [[3,6,2,4], [3,6,8,8], [6,7,5,3], [0,9,3,1]];
    auto comp1 = firstComponent(mat);
    assert(plusMinusAe(comp1.x, [1.19, -5.11, -0.537, 4.45]));
    assert(plusMinusAe(comp1.rotation, [-0.314, 0.269, -0.584, -0.698]));

    removeComponent(mat, comp1.rotation);
    normalizeColumns(mat);
    auto comp2 = firstComponentNormalized(mat);
    assert(plusMinusAe(comp2.x, [0.805, -1.779, 2.882, -1.908]));
    assert(plusMinusAe(comp2.rotation, [0.912, -0.180, -0.2498, -0.2713]));

    removeComponent(mat, comp2.rotation);
    auto comp3 = firstComponent(mat);
    assert(plusMinusAe(comp3.x, [2.277, -0.1055, -1.2867, -0.8849]));
    assert(plusMinusAe(comp3.rotation, [-0.1578, -0.5162, -0.704, 0.461]));

    // Not testing comp4 b/c basically all that's left is numerical fuzz.
}
