/**This file contains all of the plot types and Figure, which is a container
 * that draws one or more Plots onto a drawable surface.
 *
 * Copyright (C) 2010 David Simcha
 *
 * License:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
module plot2kill.figure;

import plot2kill.util;

public import plot2kill.gtkwrapper;

/**A container form for one or more Plot objects.
 *
 * Examples:
 * ---
 * auto nums = [1,1,1,1,2,2,3,3,4,5,6,7];
 * auto hist = Histogram(nums, 10);
 * auto fig = new Figure;
 * fig.addPllot(hist);
 * fig.title = "A plot";
 * fig.xLabel = "X label";
 * fig.yLabel = "Y label";
 * fig.showAsMain();
 * ---
 */
class Figure : FigureBase {
private:
    double upperLim = -double.infinity;
    double lowerLim = double.infinity;
    double leftLim = double.infinity;
    double rightLim = -double.infinity;

    double[] xAxisLocations;
    string[] xAxisText;

    double[] yAxisLocations;
    string[] yAxisText;

    // These control whether to auto set the axes.
    bool userSetXAxis = false;
    bool userSetYAxis = false;

    double topMargin = 10;
    double bottomMargin = 10;
    double leftMargin = 10;
    double rightMargin = 30;

    enum tickPixels = 10;
    double xTickLabelWidth;
    double yTickLabelWidth;
    double tickLabelHeight;

    Pen axesPen;
    Pen gridPen;


    Font _axesFont;

    void fixTickSizes() {
        void fixTickLabelSize(ref double toFix, string[] axisText) {
            toFix = 0;
            foreach(lbl; axisText) {
                auto lblSize = measureText(lbl, _axesFont);
                if(lblSize.height > tickLabelHeight) {
                    tickLabelHeight = lblSize.height;
                }

                if(lblSize.width > toFix) {
                    toFix = lblSize.width;
                }
            }
        }

        tickLabelHeight = 0;
        fixTickLabelSize(xTickLabelWidth, xAxisText);
        fixTickLabelSize(yTickLabelWidth, yAxisText);
    }

    void fixMargins() {
        fixTickSizes();
        immutable xLabelSize = measureText(xLabel(), xLabelFont());
        bottomMargin = tickLabelHeight + tickPixels + xLabelSize.height + 20;

        topMargin = measureText(title(), titleFont(), plotWidth).height + 20;

        version(noRotatedText) {
            leftMargin = measureText(yLabel(), yLabelFont(), 1).width +
                tickPixels + yTickLabelWidth + 30;
        } else {
            leftMargin = measureText(yLabel(), yLabelFont()).height +
                         tickPixels + yTickLabelWidth + 30;
        }
    }

    Plot[] plotData;
    FigureLine[] extraLines;

    final double plotWidth()  {
        return this.width - leftMargin - rightMargin;
    }

    final double plotHeight()  {
        return this.height - topMargin - bottomMargin;
    }

    mixin(toPixels);

    void drawTitle() {
        if(nullOrInit(titleFont())) {
            return;
        }

        auto rect = PlotRect(leftMargin,
            topMargin / 4, this.plotWidth, topMargin * 3 / 4);
        auto format = TextAlignment.Center;
        drawText(title(), titleFont(), getColor(0, 0, 0), rect, format);
    }

    void drawXlabel() {
        if(nullOrInit(xLabelFont())) {
            return;
        }

        immutable textSize = measureText(xLabel(), xLabelFont());
        auto rect = PlotRect(leftMargin, this.height - textSize.height - 10,
            this.width - leftMargin - rightMargin, textSize.height);

        auto format = TextAlignment.Center;
        drawText(xLabel(), xLabelFont(), getColor(0, 0, 0), rect, format);
    }

    void drawYlabel() {
        if(nullOrInit(yLabelFont()) || yLabel().length == 0) {
            return;
        }

        immutable textSize = measureText(yLabel(), yLabelFont());
        immutable margin = (plotHeight - textSize.width) / 2 + topMargin;
        auto rect = PlotRect(10, margin, textSize.height, textSize.width);

        drawRotatedText(yLabel(),
            yLabelFont(), getColor(0, 0, 0), rect, TextAlignment.Center);
    }

    void drawExtraLines() {
        foreach(line; extraLines) {
            auto pen = getPen(line.lineColor, line.lineWidth);
            scope(exit) doneWith(pen);

            auto start = PlotPoint(toPixelsX(line.x1), toPixelsY(line.y1));
            auto end = PlotPoint(toPixelsX(line.x2), toPixelsY(line.y2));
            drawClippedLine(pen, start, end);
        }
    }

    void drawAxes() {
        immutable origin = PlotPoint(toPixelsX(leftLim), toPixelsY(lowerLim));
        immutable topLeft = PlotPoint(origin.x, toPixelsY(upperLim));
        immutable bottomRight = PlotPoint(toPixelsX(rightLim), origin.y);

        drawLine(axesPen, origin, topLeft);
        drawLine(axesPen, origin, bottomRight);

        foreach(i, tickPoint; xAxisLocations) {
            drawXTick(tickPoint, xAxisText[i]);
        }

        foreach(i, tickPoint; yAxisLocations) {
            drawYTick(tickPoint, yAxisText[i]);
        }
    }

    // Controls the space between a tick line and the tick label.
    enum lineLabelSpace = 2;

    void drawXTick(double where, string text) {
        immutable wherePixels = toPixelsX(where);
        drawLine(
            axesPen,
            PlotPoint(wherePixels, this.height - bottomMargin),
            PlotPoint(wherePixels, this.height - bottomMargin + tickPixels)
        );

        if(verticalGrid) {
            drawLine(gridPen,
                PlotPoint(wherePixels, topMargin),
                PlotPoint(wherePixels, this.height - bottomMargin));
        }

        if(nullOrInit(_axesFont)) {
            return;
        }

        auto format = TextAlignment.Center;

        immutable textSize = measureText(text, _axesFont, format);
        auto rect = PlotRect(wherePixels - textSize.width / 2,
            this.height - bottomMargin  + tickPixels + lineLabelSpace,
            textSize.width,
            textSize.height
        );

        drawText(text, _axesFont, getColor(0, 0, 0), rect, format);
    }

    void drawYTick(double where, string text) {
        immutable wherePixels = this.height - toPixelsY(where);
        drawLine(
            axesPen,
            PlotPoint(leftMargin, this.height - wherePixels),
            PlotPoint(leftMargin - tickPixels, this.height - wherePixels)
        );

        if(nullOrInit(_axesFont)) {
            return;
        }

        if(horizontalGrid) {
            drawLine(
                gridPen,
                PlotPoint(leftMargin, this.height - wherePixels),
                PlotPoint(this.width - rightMargin, this.height - wherePixels));
        }

        auto format = TextAlignment.Right;

        immutable textSize = measureText(text, _axesFont, format);
        auto rect = PlotRect(
            leftMargin - textSize.width - tickPixels - lineLabelSpace,
            this.height - wherePixels - textSize.height / 2,
            textSize.width,
            textSize.height
        );

        drawText(text, _axesFont, getColor(0, 0, 0), rect, format);
    }

    void setupAxes(
        double lower,
        double upper,
        ref double[] axisLocations,
        ref string[] axisText,
        double axisSize,
        ref double labelSize,
    )
    in {
        assert(upper > lower, std.conv.text(lower, '\t', upper));
    } body {

        immutable diff = upper - lower;

        double tickWidth = 10.0 ^^ floor(log10(diff));
        if(diff / tickWidth < 2) {
            tickWidth /= 10;
        }

        if(diff / tickWidth > 9) {
            tickWidth *= 2;
        }


        if(diff / tickWidth < 4) {
            tickWidth /= 2;
        }

        double startPoint = ceil(lower / tickWidth) * tickWidth;
        do {
            // The tickWidth * 0.01 is a fudge factor to make the last tick
            // get drawn in the presence of rounding error.
            axisLocations = array(
                iota(startPoint, upper + tickWidth * 0.01, tickWidth)
            );

            axisText = doublesToStrings(axisLocations);
            fixMargins();

            // Prevent labels from running together on small plots.
            if(axisSize / axisLocations.length < labelSize * 2
               && diff / tickWidth > 2) {
                tickWidth *= 2;
                startPoint = ceil(lower / tickWidth) * tickWidth;
                continue;
            } else {
                break;
            }
        } while(true);
    }

    void setLim(
        double lower,
        double upper,
        ref double oldLower,
        ref double oldUpper,
    ) {
        enforce(upper > lower, "Can't have upper limit < lower limit.");
        oldLower = lower;
        oldUpper = upper;
    }

    void nullFontsToDefaults() {
        if(nullOrInit(titleFont())) {
            _titleFont = getFont(plot2kill.util.defaultFont, 14 + fontSizeAdjust);
        }
        if(nullOrInit(xLabelFont())) {
            _xLabelFont = getFont(plot2kill.util.defaultFont, 14 + fontSizeAdjust);
        }

        if(nullOrInit(yLabelFont())) {
            _yLabelFont = getFont
                (plot2kill.util.defaultFont, 14 + fontSizeAdjust);
        }

        if(nullOrInit(axesFont())) {
            _axesFont = getFont(plot2kill.util.defaultFont, 12 + fontSizeAdjust);
        }
    }

    static bool isValidPlot(Plot plot) {
        if(plot is null) {
            return false;
        }

        return plot.leftMost <= plot.rightMost &&
            plot.bottomMost <= plot.topMost;
    }
protected:

    this() {}

    this(Plot[] plots...) {
        this();
        addPlot!(Figure)(plots);
    }

public:

    override int defaultWindowWidth() {
        return 800;
    }

    override int defaultWindowHeight() {
        return 600;
    }

    override int minWindowWidth() {
        return 400;
    }

    override int minWindowHeight() {
        return 300;
    }

    // These drawing commands aren't documented for now b/c they're subject
    // to change.

    // Returns whether any part of the rectangle is on screen.
    bool clipRectangle(ref double x, ref double y, ref double width, ref double height) {
        // Do clipping.
        auto bottom = y + height;
        auto right = x + width;
        if(x < leftMargin) {
            x = leftMargin;
        }
        if(right > this.width - rightMargin) {
            right = this.width - rightMargin;
        }

        if(y < topMargin) {
            y = topMargin;
        }

        if(bottom > this.height - bottomMargin) {
            bottom = this.height - bottomMargin;
        }

        width = right - x;
        height = bottom - y;
        return width > 0 && height > 0;
    }

    // Convenience
    static bool between(T, U, V)(T num, U lower, V upper) {
        return lower <= num && num <= upper;
    }

    bool clipLine(ref double x1, ref double y1, ref double x2, ref double y2) {
        immutable topPixel = topMargin;
        immutable bottomPixel = this.height - bottomMargin - 1;
        immutable leftPixel = leftMargin + 1;
        immutable rightPixel = this.width - rightMargin;
        if(between(x1, leftPixel, rightPixel) &&
           between(x2, leftPixel, rightPixel) &&
           between(y1, topPixel, bottomPixel) &&
           between(y2, topPixel, bottomPixel)) {

            return true;
        }

        // Handle slope of zero or infinity as a special case.
        if(x1 == x2) {
            if(!between(x1, leftPixel, rightPixel)) {
                return false;
            } else if(y1 < topPixel && y2 < topPixel) {
                return false;
            } else if(y1 > bottomPixel && y2 > bottomPixel) {
                return false;
            }

            y1 = max(y1, topPixel);
            y1 = min(y1, bottomPixel);
            y2 = max(y2, topPixel);
            y2 = min(y2, bottomPixel);
            return true;
        } else if(y1 == y2) {
            if(!between(y1, topPixel, bottomPixel)) {
                return false;
            } else if(x1 < leftPixel && x2 < leftPixel) {
                return false;
            } else if(x1 > rightPixel && x2 > rightPixel) {
                return false;
            }

            x1 = max(x1, leftPixel);
            x1 = min(x1, rightPixel);
            x2 = max(x2, leftPixel);
            x2 = min(x2, rightPixel);
            return true;
        }

        immutable slope = (y2 - y1) / (x2 - x1);
        enum tol = 0;  // Compensate for rounding error.

        void fixX(ref double x, ref double y) {
            if(x < leftPixel) {
                immutable diff = leftPixel - x;
                x = leftPixel;
                y = diff * slope + y;
            } else if(x > rightPixel) {
                immutable diff = rightPixel - x;
                x = rightPixel;
                y = diff * slope + y;
            }
        }

        void fixY(ref double x, ref double y) {
            if(y < topPixel) {
                immutable diff = topPixel - y;
                y = topPixel;
                x = diff / slope + x;
            } else if(y > bottomPixel) {
                immutable diff = bottomPixel - y;
                y = bottomPixel;
                x = diff / slope + x;
            }
        }
        fixX(x1, y1);
        fixX(x2, y2);
        fixY(x1, y1);
        fixY(x2, y2);

        // This prevents weird rounding artifacts where a line appears as a
        // single point on the edge of the figure.
        if(y1 == y2 && x1 == x2 && (
            (y1 == topPixel || y1 == bottomPixel) ||
            (x1 == leftPixel || x1 == rightPixel))) {
            return false;
        }

        // The minuses and pluses are to deal w/ rounding error.
        return between(x1, leftPixel - tol, rightPixel + tol) &&
               between(x2, leftPixel - tol, rightPixel + tol) &&
               between(y1, topPixel - tol, bottomPixel + tol) &&
               between(y2, topPixel - tol, bottomPixel + tol);
    }

    void drawClippedRectangle
    (Pen pen, double x, double y, double width, double height) {
        if(clipRectangle(x, y, width, height)) {
            drawRectangle(pen, x, y, width, height);
        }
    }

    void drawClippedRectangle(Pen pen, PlotRect r) {
        drawClippedRectangle(pen, r.x, r.y, r.width, r.height);
    }

    void fillClippedRectangle
    (Brush brush, double x, double y, double width, double height) {
        if(clipRectangle(x, y, width, height)) {
            fillRectangle(brush, x, y, width, height);
        }
    }

    void fillClippedRectangle(Brush brush, PlotRect rect) {
        fillClippedRectangle(brush, rect.x, rect.y, rect.width, rect.height);
    }

    void drawClippedLine(Pen pen, PlotPoint from, PlotPoint to) {
        auto x1 = from.x;
        auto y1 = from.y;
        auto x2 = to.x;
        auto y2 = to.y;
        immutable shouldDraw = clipLine(x1, y1, x2, y2);

        if(!shouldDraw) {
            return;
        }

        drawLine(pen, PlotPoint(x1, y1), PlotPoint(x2, y2));
    }

    void drawClippedText(string text, Font font,
        Color pointColor, PlotRect rect) {

        // To avoid cutting points off of scatter plots, this function only
        // checks whether the center of each point is on the graph.  Therefore,
        // it may allow points to extend slightly off the graph.  This is
        // annoying, but there's no easy way to fix it w/o risking cutting off
        // points.
        immutable xMid = rect.x + rect.width / 2;
        immutable yMid = rect.y + rect.height / 2;

        if(between(xMid, leftMargin, this.width - rightMargin) &&
           between(yMid, topMargin, this.height - bottomMargin)) {
            drawText(text, font, pointColor, rect);
        }
    }

    ///
    final Font axesFont()() {
        return _axesFont;
    }

    ///
    final This axesFont(this This)(Font newFont) {
        _axesFont = newFont;
        return cast(This) this;
    }

    ///
    static Figure opCall() {
        return new Figure;
    }

    /**Convenience factory that adds all plots provided to the Figure.*/
    static Figure opCall(Plot[] plots...) {
        return new Figure(plots);
    }

    /**Manually set the X axis limits.
     */
    final This xLim(this This)(double newLower, double newUpper) {
        setLim(newLower, newUpper, leftLim, rightLim);
        return cast(This) this;
    }

    /**Manually set the Y axis limits.
     */
    This yLim(this This)(double newLower, double newUpper) {
        setLim(newLower, newUpper, lowerLim, upperLim);
        return cast(This) this;
    }

    /**Set the X axis labels.  If text is null (default) the axis text is
     * just the text of the axis locations.  R should be any range with
     * length identical to text (unless text is null) and elements implicitly
     * convertible to double.
     */
    This xTickLabels(R, this This)(R locations, const string[] text = null)
    if(isInputRange!R && is(ElementType!R : double)) {
        userSetXAxis = true;
        xAxisLocations = toDoubleArray(locations);

        if(text.length > 0) {
            enforce(text.length == xAxisLocations.length,
                "Length mismatch between X axis locations and X axis text.");
            xAxisText = text.dup;
        } else {
            xAxisText = doublesToStrings(xAxisLocations);
        }

        return cast(This) this;
    }

    /**Set the Y axis labels.  If text is null (default) the axis text is
     * just the text of the axis locations.  R should be any range with
     * length identical to text (unless text is null) and elements implicitly
     * convertible to double.
     */
    This yTickLabels(R, this This)(R locations, const string[] text = null)
    if(isInputRange!R && is(ElementType!R : double)) {
        userSetYAxis = true;
        yAxisLocations = toDoubleArray(locations);

        if(text.length > 0) {
            enforce(text.length == xAxisLocations.length,
                "Length mismatch between Y axis locations and X axis text.");
            yAxisText = text.dup;
        } else {
            yAxisText = doublesToStrings(yAxisLocations);
        }

        return cast(This) this;
    }

    /**Determines whether horizontal gridlines are drawn.  Default is false.*/
    bool horizontalGrid = false;

    /**Determines whether vertical gridlines are drawn. Default is false.*/
    bool verticalGrid = false;

    /**The leftmost point on the figure.*/
    double leftMost()  {
        return leftLim;
    }

    /**The rightmost point on the figure.*/
    double rightMost()  {
        return rightLim;
    }

    /**The topmost point on the figure.*/
    double topMost()  {
        return upperLim;
    }

    /**The bottommost point on the figure.*/
    double bottomMost()  {
        return lowerLim;
    }

    /**Add individual lines to the figure.  Coordinates are specified relative
     * to the plot area, not in pixels.  The lines are is clipped
     * to the visible part of the plot area.  This is useful for adding
     * annotation lines, as opposed to plot lines.
     */
    This addLines(this This)(FigureLine[] lines...) {
        extraLines ~= lines;
        return cast(This) this;
    }

    /**Add one or more plots to the figure.*/
    This addPlot(this This)(Plot[] plots...) {
        foreach(plot; plots) {
            if(!isValidPlot(plot)) {
                continue;
            }

            upperLim = max(upperLim, plot.topMost);
            rightLim = max(rightLim, plot.rightMost);
            leftLim = min(leftLim, plot.leftMost);
            lowerLim = min(lowerLim, plot.bottomMost);
            plotData ~= plot;
        }

        return cast(This) this;
    }

    /**Draw the plot but don't display it on screen.*/
    override void drawImpl() {
        auto whiteBrush = getBrush(getColor(255, 255, 255));
        fillRectangle(whiteBrush, 0, 0, this.width, this.height);
        doneWith(whiteBrush);
        // If this is not a valid Figure, leave a big blank white rectangle.
        // It beats crashing.
        if(!(leftLim < rightLim && lowerLim < upperLim)) {
            return;
        }
        axesPen = getPen(getColor(0, 0, 0), 2);
        scope(exit) doneWith(axesPen);

        gridPen = getPen(getColor(0, 0, 0), 1);
        scope(exit) doneWith(gridPen);

        nullFontsToDefaults();

        if(!userSetXAxis) {
            setupAxes(leftLim, rightLim, xAxisLocations, xAxisText,
                this.width, xTickLabelWidth);
        }

        if(!userSetYAxis) {
            setupAxes(lowerLim, upperLim, yAxisLocations, yAxisText,
                this.height, tickLabelHeight);
        }

        fixMargins();

        foreach(plot; plotData) {
            if(!isValidPlot(plot)) {
                continue;
            }

            immutable x = toPixelsX(plot.leftMost);
            immutable y = toPixelsY(plot.topMost);
            immutable subHeight = toPixelsY(plot.bottomMost) - y;
            immutable subWidth = toPixelsX(plot.rightMost) - x;
            plot.drawPlot(this, x, y, subWidth, subHeight);
        }

        drawYlabel();
        drawExtraLines();
        drawAxes();
        drawTitle();
        drawXlabel();
    }

    version(none) {
    void showUsingImplicitMain() {
        ImplicitMain.initialize();
        ImplicitMain.addForm(this);
    }
    }
}

/**For drawing extra lines on a Figure, with coordinates specified in plot
 * units and relative to the plot area, not in pixels.*/
struct FigureLine {
private:
    double x1;
    double y1;
    double x2;
    double y2;
    Color lineColor;
    uint lineWidth = 1;

public:
    this(double x1, double y1, double x2,
         double y2, Color lineColor, uint lineWidth = 1) {

        enforce(isFinite(x1) && isFinite(x2) && isFinite(y1) && isFinite(y2),
                "Line coordinates must be finite.");
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.lineColor = lineColor;
        this.lineWidth = lineWidth;
    }
}


/**Abstract base class for all types of plot objects.*/
abstract class Plot {
protected:
    // Top of the plot.
    double upperLim = -double.infinity;

    // Bottom of the plot.
    double lowerLim = double.infinity;

    // Leftmost limit of the plot.
    double leftLim = double.infinity;

    // Rightmost limit of the plot.
    double rightLim = -double.infinity;

public:
    /* Draw the plot on Figure using the rectangular area described by the
     * integer parameters.
     */
    abstract void drawPlot(Figure, double, double, double, double);

    /**Convenience method that instantiates a Figure object with this plot.
     * Useful for creating single-plot figures w/o a lot of boilerplate.
     *
     * Examples:
     * ---
     * auto hist = Histogram([1,2,3,4,5], 3).toFigure;
     * hist.showAsMain();
     * ---
     */
    Figure toFigure()  {
        return new Figure(this);
    }

    /**Instantiates a Figure object with this plot and also places the default
     * axes and tick labeling and title for the plot type, if any, on the
     * Figure.  If a plot type has no default labeling, simply forwards to
     * toFigure().
     */
    Figure toLabeledFigure()  {
        return toFigure;
    }

    /**The leftmost point on the plot.*/
    double leftMost()  {
        return leftLim;
    }

    /**The rightmost point on the plot.*/
    double rightMost()  {
        return rightLim;
    }

    /**The topmost point on the plot.*/
    double topMost()  {
        return upperLim;
    }

    /**The bottommost point on the plot.*/
    double bottomMost()  {
        return lowerLim;
    }
}

/**A basic bar plot.*/
class BarPlot : Plot {
private:
    double[] _centers;
    double[] _heights;
    double[] _lowerErrors;
    double[] _upperErrors;


    void fixBounds() {
        this.leftLim = reduce!min(double.infinity, this.centers) - width / 2;
        this.rightLim = reduce!max(-double.infinity, this.centers) + width / 2;
        lowerLim = double.infinity;
        upperLim = -double.infinity;

        foreach(i, height; _heights) {
            if(lowerErrors.length > 0) {
                lowerLim = min(height - lowerErrors[i], lowerLim);
            } else {
                lowerLim = min(height, lowerLim);
            }

            if(upperErrors.length > 0) {
                upperLim = max(height + upperErrors[i], upperLim);
            } else {
                upperLim = max(height, upperLim);
            }
        }

        // Don't blend error bars into axes.  Handle the case where a boundary
        // is 0 as a special case, since it would look worse to have the axis
        // not be exactly zero if all bars are positive or all are negative than
        // to blend an error bar into an axis.
        if(upperErrors.length || lowerErrors.length) {
            immutable pad = 0.01 * (upperLim - lowerLim);
            if(upperErrors.length && upperLim != 0) {
                upperLim += pad;
            }
            if(lowerErrors.length && lowerLim != 0) {
                lowerLim -= pad;
            }
        }

        if(lowerLim > 0) {
            lowerLim = 0;
        }

        if(upperLim < 0) {
            upperLim = 0;
        }
    }


    this(double[] centers, double[] heights, double width) {
        this._centers = centers;
        this._heights = heights;
        this.width = width;
        _barColor = getColor(0, 0, 255);
        fixBounds();
    }

protected:
    void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {

        mixin(toPixels);
        mixin(drawErrorMixin);

        immutable multiplier = plotHeight / (this.upperLim - this.lowerLim);
        immutable zeroPoint = toPixelsY(0);
        auto brush = form.getBrush(_barColor);
        scope(exit) doneWith(brush);

        auto blackPen = form.getPen(getColor(0, 0, 0));
        scope(exit) doneWith(blackPen);

        foreach(i, center; centers) {
            immutable height = heights[i];
            immutable left = center - width / 2;
            immutable right = center + width / 2;
            immutable leftPixels = toPixelsX(left);
            immutable rightPixels = toPixelsX(right);
            immutable widthPixels = rightPixels - leftPixels;

            immutable heightPixels = roundTo!int(abs(height) * multiplier);

            immutable startAt = (height > 0) ?
                                zeroPoint - heightPixels :
                                zeroPoint;
            form.fillClippedRectangle(brush, leftPixels,
                startAt, widthPixels, heightPixels);
            form.drawClippedRectangle(blackPen, leftPixels,
                startAt, widthPixels, heightPixels);

            // Do error bars.
            if(lowerErrors.length) {
                drawErrorBar(blackPen,
                    center, height, height - lowerErrors[i], width / 2);
            }
            if(upperErrors.length) {
                drawErrorBar(blackPen,
                    center, height, height + upperErrors[i], width / 2);
            }
        }

        if(lowerLim < 0) {
            auto pen = form.getPen(getColor(0, 0, 0), 2);
            // Draw line across figure at the zero point.
            form.drawClippedLine(pen,
                PlotPoint(toPixelsX(leftLim), zeroPoint),
                PlotPoint(toPixelsX(rightLim), zeroPoint)
            );
        }
    }

    Color _barColor;

public:
    /**Controls the color of the bar.  Defaults to blue.*/
    final Color barColor()() {
        return _barColor;
    }

    /// Setter
    final This barColor(this This)(Color newColor) {
        _barColor = newColor;
        return cast(This) this;
    }

    ///
    immutable double width;

    /**Create a BarPlot.  centers and heights must be input ranges with elements
     * implicitly convertible to double.  width determines the width of each
     * bar relative to the X-axis scale and must be greater than 0.
     */
    static BarPlot opCall(R1, R2)(R1 centers, R2 heights, double width)
    if(isInputRange!R1 && is(ElementType!R1 : double) &&
       isInputRange!R2 && is(ElementType!R2 : double)) {

        auto c = toDoubleArray(centers);
        auto h = toDoubleArray(heights);

        enforce(c.length == h.length,
            "Centers and heights must be same length for bar plot.");

        enforce(width > 0, "Width must be >0 for bar plot.");
        auto ret = new typeof(return)(c, h, width);
        return ret;
    }

    /**Create a BarPlot with error bars.  lowerErrors and upperErrors
     * must be input ranges with elements implicitly convertible to double for
     * error bars to be shown.  Any other value, such as null or 0, will result
     * in no error bars being shown.  Therefore, to only show, for example,
     * upper erros, simply pass in null or 0 for the lower errors.
     *
     * To draw symmetric error bars, simply pass in the same range for
     * lowerErrors and upperErrors.  However, note that if you do this,
     * the range will need to be a forward range, not an input range.
     */
     static BarPlot opCall(R1, R2, R3, R4)
     (R1 centers, R2 heights, double width, R3 lowerErrors, R4 upperErrors)
     if(isInputRange!R1 && is(ElementType!R1 : double) &&
        isInputRange!R2 && is(ElementType!R2 : double)) {

        auto ret = opCall(centers, heights, width);
        static if(isForwardRange!R3) {
            ret._lowerErrors = toDoubleArray(lowerErrors.save);
        } else static if(isInputRange!R3) {
            ret._lowerErrors = toDoubleArray(lowerErrors);
        }

        static if(isForwardRange!R4) {
            ret._upperErrors = toDoubleArray(upperErrors.save);
        } else static if(isInputRange!R4) {
            ret._upperErrors = toDoubleArray(upperErrors);
        }

        enforce(ret.upperErrors.length == 0 || ret.upperErrors.length ==
            ret.centers.length, "Length of upperErrors must equal number of bars.");
        enforce(ret.lowerErrors.length == 0 || ret.lowerErrors.length ==
            ret.centers.length, "Length of lowerErrors must equal number of bars.");

        ret.fixBounds();
        return ret;
    }

    /**Scale this object by a factor of scaleFactor in the X direction.
     * This is useful for getting it onto the same scale as another plot.
     */
    void scaleCenters(double scaleFactor) {
        enforce(isFinite(scaleFactor), "Can't scale by infinity or NaN.");
        _centers[] *= scaleFactor;
        fixBounds();
    }

    /**Scale this object by a factor of scaleFactor in the Y direction.
     * This is useful for getting it onto the same scale as another plot.*/
    void scaleHeights(double scaleFactor) {
        enforce(isFinite(scaleFactor), "Can't scale by infinity or NaN.");
        _heights[] *= scaleFactor;
        fixBounds();
    }

    /**Shift this graph by shiftBy units in the X direction.
     * This is useful for getting it onto the same scale as another plot.
     */
    void shiftCenters(double shiftBy) {
        enforce(isFinite(shiftBy), "Can't shift by infinity or NaN.");
        _centers[] += shiftBy;
        fixBounds();
    }

    /**Get the centers of the bars.*/
    final const(double)[] centers()  {
        return _centers;
    }

    /**Get the heights of the bars.*/
    final const(double)[] heights()  {
        return _heights;
    }

    ///
    final const(double)[] lowerErrors()  {
        return _lowerErrors;
    }

    ///
    final const(double)[] upperErrors()  {
        return _upperErrors;
    }

    /**The default labeling includes each center receiving its own x tick
     * label if there are <= 10 bars on the graph.
     */
    override Figure toLabeledFigure()  {
        auto ret = toFigure;
        if(centers.length <= 10) {
            ret.xTickLabels(centers);
        }

        return ret;
    }
}


/**Determine behavior for elements outside of a fixed-border histogram's bounds.
 */
enum OutOfBounds {
     /** Throw throws an exception.*/
    Throw,

    /**Ignore simply skips the number.*/
    Ignore
}

/**Controls whether a histogram plots counts or probability.*/
enum HistType {
    /// The Y-axis should be counts.
    Counts,

    /// The Y-axis should be probabilities.
    Probability
}

/**A class for plotting regular (equal-width) histograms.*/
class Histogram : Plot {

    private double binWidth;

    private uint[] binCounts;
    private uint nElem;

    private HistType countsOrProbs;

    private this() {
        _barColor = getColor(0, 0, 255);
    }

    private bool isCumulative = false;

    protected void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        uint[] binCounts = this.binCounts;
        if(isCumulative) {
            binCounts = binCounts.dup;
            foreach(i; 1..binCounts.length) {
                binCounts[i] += binCounts[i - 1];
            }
        }

        immutable maxCount = reduce!max(0U, binCounts);
        immutable multiplier = plotHeight / cast(double) maxCount;

        immutable binWidth = cast(double) plotWidth / nBin;
        immutable bottom = plotHeight + topMargin;

        auto blackPen = form.getPen(getColor(0, 0, 0), 1);
        scope(exit) doneWith(blackPen);

        auto brush = form.getBrush(_barColor);
        scope(exit) doneWith(brush);

        double horizPos = leftMargin;
        double lastPosPixels = leftMargin;
        foreach(i, count; binCounts) {
            // Most of the complexity of this loop body is for making the bin
            // boundaries accurate in the context of having to round to
            // pixels.
            immutable barHeight = multiplier * count;
            immutable horizPixels = min(roundTo!int(horizPos), lastPosPixels);
            immutable stopAt = horizPos + binWidth;
            immutable thisBinWidth = max(1.0, stopAt - horizPixels);

            form.fillClippedRectangle(brush, lastPosPixels,
                bottom - barHeight, thisBinWidth, barHeight);
            form.drawClippedRectangle(blackPen, lastPosPixels,
                bottom - barHeight, thisBinWidth, barHeight);
            horizPos += binWidth;
            lastPosPixels = horizPixels + thisBinWidth;
        }
    }

    private void fixBounds() {
        if(isCumulative) {
            if(countsOrProbs == HistType.Probability) {
                upperLim = 1;
            } else {
                upperLim = nElem;
            }
        } else{
            if(countsOrProbs == HistType.Probability) {
                upperLim = reduce!max(0U, binCounts) / cast(double) nElem;
            } else {
                upperLim = reduce!max(0U, binCounts);
            }
        }
    }

    private OutOfBounds outOfBoundsBehavior = OutOfBounds.Throw;

    private Color _barColor;

    /**Controls the color of the bar.  Defaults to blue.*/
    final Color barColor()() {
        return _barColor;
    }

    /// Setter
    final This barColor(this This)(Color newColor) {
        _barColor = newColor;
        return cast(This) this;
    }

    /// The number of bins this histogram contains.
    final uint nBin() const pure nothrow  {
        return binCounts.length;
    }

    /**Factory method to instantiate this class.  nums must be a forward range
     * with elements implicitly convertible to double.  nBin specifies how many
     * bins the histogram should contain.
     */
    static Histogram opCall(R)(R nums, uint nBin)
    if(isForwardRange!R && is(ElementType!R : double)) {
        double leftLim = double.infinity, rightLim = -double.infinity;
        foreach(num; nums.save) {
            leftLim = min(leftLim, num);
            rightLim = max(rightLim, num);
        }

        return Histogram(nums, nBin, leftLim, rightLim);
    }

    /**Factory method to instantiate this class with predetermined limits.
     * This allows nums to be an input range instead of a forward range, since
     * no pass is necessary to compute the limits.
     *
     * This function both obeys and permanently sets whatever bounds behavior
     * is specified (throwing or ignoring on out of bounds numbers).  The
     * default behavior is to throw.  Rationale:  Errors should only pass
     * silently if explicitly silenced.
     */
    static Histogram opCall(R)(
        R nums,
        uint nBin,
        double leftLim,
        double rightLim,
        OutOfBounds outOfBoundsBehavior = OutOfBounds.Throw
    ) if(isInputRange!R && is(ElementType!R : double)) {
        auto ret = Histogram(nBin, leftLim, rightLim, outOfBoundsBehavior);

        foreach(num; nums) {
            ret.put(num);
        }

        return ret;
    }

    /**Create an empty histogram with pre-specified bounds, which will be
     * filled with data using the put method.
     *
     * Note:  The only reason this is a template is because of bugs in
     * overloading non-templated functions agsinst templated functions.
     */
    static Histogram opCall(I)(
        I nBin,
        double leftLim,
        double rightLim,
        OutOfBounds outOfBoundsBehavior = OutOfBounds.Throw
    ) if(isIntegral!I) {
        auto ret = new Histogram;
        ret.outOfBoundsBehavior = outOfBoundsBehavior;

        enforce(rightLim > leftLim,
            "Cannot create a histogram w/ upper lim <= lower lim.");
        enforce(nBin > 1, "Cannot create a histogram w/ <2 bins.");

        immutable binWidth = (rightLim - leftLim) / nBin;
        ret.binWidth = binWidth;

        ret.leftLim = leftLim;
        ret.rightLim = rightLim;
        ret.binCounts.length = to!uint(nBin);
        ret.lowerLim = 0;
        ret.upperLim = 0;

        return ret;
    }

    /**Add a number to the histogram on the fly.*/
    This put(this This)(double num) {
        if(outOfBoundsBehavior == OutOfBounds.Throw) {
            enforce(num >= leftLim && num <= rightLim, text(
                "Number out of bounds for histogram.  Got:  ", num,
                ", expected between ", leftLim, " and ", rightLim, "."));
        } else {
            if(!(num >= leftLim && num <= rightLim)) {
                return cast(This) this;
            }
        }

        uint bin;
        bin = to!uint((num - leftLim) / binWidth);
        if(bin == nBin) {  // Edge case.
            bin--;
        }

        binCounts[bin]++;
        nElem++;

        if(countsOrProbs == HistType.Counts) {
            if(isCumulative) {
                upperLim = nElem;
            } else if(binCounts[bin] > upperLim) {
                upperLim = binCounts[bin];
            }
        } else if(!isCumulative) {
            immutable binProb = binCounts[bin] / cast(double) nElem;
            if(binProb > upperLim) {
                upperLim = binProb;
            }
        }

        return cast(This) this;
    }

    /**Add the contents of another Histogram to this one.  The boundaries and
     * numbers of bins must be the same.  This histogram's settings are
     * retained.
     */
    This put(this This)(const Histogram rhs) {
        if(rhs is null) {
            return cast(This) this;
        }

        enforce(rhs.leftLim == this.leftLim && rhs.rightLim == this.rightLim,
            "Boundaries must be the same to combine histograms.");
        binCounts[] += rhs.binCounts[];
        nElem += rhs.nElem;

        fixBounds();
        return cast(This) this;
    }

    /**Assumes the LineGraph input is a plot of a PDF that this histogram is
     * supposed to approximate, and scales the Y axis of the LineGraph
     * accordingly so that both appear on the same scale.
     *
     * If this Histogram is cumulative, assumes that the input LineGraph is
     * a CDF instead.
     */
    This scaleDistributionFunction(this This)(LineGraph g) {
        if(isCumulative) {
            if(countsOrProbs == HistType.Counts) {
                g.scaleY(nElem);
            }
        // Don't need to do anything if this is a probability histogram.
        } else {
            double scaleFactor = (rightLim - leftLim) / nBin;
            if(countsOrProbs == HistType.Counts) {
                scaleFactor *= nElem;
            }

            g.scaleY(scaleFactor);
        }

        return cast(This) this;
    }

    /**Determine whether this object throws or ignores if it receives a number
     * outside its bounds via put.
     */
    This boundsBehavior(this This)(OutOfBounds behavior)  {
        outOfBoundsBehavior = behavior;
        return cast(This) this;
    }

    /**Set whether this histogram displays counts or probabilities.*/
    This histType(this This)(HistType newType) {
        countsOrProbs = newType;
        fixBounds();
        return cast(This) this;
    }

    /**Determines whether this histogram is cumulative.*/
    This cumulative(this This)(bool newVal) {
        isCumulative = newVal;
        fixBounds();
        return cast(This) this;
    }
}

/**Creates a histogram with equal frequency binning instead of equal width
 * binning.  The scale of a FrequencyHistogram is the probability density scale.
 *
 * Note that equal frequency binning doesn't work with discrete
 * distributions where probability density may be infinite at a point.
 * Therefore, if a probability density is calculated to be infinite, this
 * class will throw.
 *
 *
 */
class FrequencyHistogram : Plot {
    private double[] binWidths;
    private double elemsPerBin;

    private Color _barColor;

    this() {
        _barColor = getColor(0, 0, 255);
    }

    protected void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {

        mixin(toPixels);

        immutable multiplier = plotHeight / (this.upperLim - this.lowerLim);
        immutable zeroPoint = toPixelsY(0);
        auto brush = form.getBrush(_barColor);
        scope(exit) doneWith(brush);
        auto pen = form.getPen(_barColor, 1);
        scope(exit) doneWith(pen);

        auto blackPen = form.getPen(getColor(0, 0, 0));
        scope(exit) doneWith(blackPen);

        double xStart = leftLim;
        immutable totalWidth = rightLim - leftLim;
        foreach(width; binWidths) {
            scope(exit) xStart += width;
            immutable height = totalWidth / width / elemsPerBin;
            immutable leftPixels = toPixelsX(xStart);
            immutable rightPixels = toPixelsX(xStart + width);
            immutable widthPixels = rightPixels - leftPixels;
            immutable heightPixels = height * multiplier;

            immutable startAt = zeroPoint - heightPixels;

            form.fillClippedRectangle(brush, leftPixels,
                startAt, widthPixels, heightPixels);

            form.drawClippedRectangle(pen, leftPixels,
                startAt, widthPixels, heightPixels);

            // Don't outline rectangle because for equal-frequency
            // histograms this is more distracting than readable.
        }
    }

    /**Controls the color of the bar.  Defaults to blue.*/
    final Color barColor()() {
        return _barColor;
    }

    /// Setter
    final This barColor(this This)(Color newColor) {
        _barColor = newColor;
        return cast(This) this;
    }

    /**Create a FrequencyHistogram.  R must be an input range with elements
     * implicitly convertible to double.  nBin must be > 0 and <= nums.length.
     *
     * Throws:  Exception if the density for any bin is infinite.
     */
    static FrequencyHistogram opCall(R)(R nums, uint nBin) {
        auto numArr = toDoubleArray(nums);
        enforce(numArr.length >= nBin,
            "Can't create an equal-frequency histogram w/ < nBin elements.");

        sort(numArr);
        auto binWidths = new double[nBin];

        auto ret = new typeof(return);
        ret.leftLim = numArr[0];
        ret.rightLim = numArr[$ - 1];
        ret.lowerLim = 0;

        // Use linear interpolation to deal w/ non-integer elements/bin.
        immutable elemsPerBin = numArr.length / cast(double) nBin;
        double lastBinStop = numArr[0];
        foreach(i; 0..nBin) {
            immutable floatIndex = elemsPerBin * (i + 1);
            immutable indexFract = floatIndex - floor(floatIndex);
            size_t lowerIndex = to!size_t(floatIndex);
            size_t upperIndex = to!size_t(ceil(floatIndex));

            if(upperIndex >= numArr.length) {
                upperIndex = numArr.length - 1;
            }
            if(lowerIndex >= numArr.length) {
                lowerIndex = numArr.length - 1;
            }

            immutable diff = numArr[upperIndex] - numArr[lowerIndex];
            immutable curBinStop = numArr[lowerIndex] + diff * indexFract;

            binWidths[i] = curBinStop - lastBinStop;
            enforce(binWidths[i] > 0,
                "Can't create an equal-frequency histogram when some bin " ~
                "widths are 0."
            );
            lastBinStop = curBinStop;
        }

        ret.binWidths = binWidths;
        ret.elemsPerBin = elemsPerBin;
        immutable totalWidth = ret.rightLim - ret.leftLim;
        ret.upperLim = totalWidth / reduce!min(binWidths) / elemsPerBin;
        return ret;
    }

    override Figure toLabeledFigure()  {
        auto ret = toFigure;
        ret.yLabel = "Probability Density";
        return ret;
    }
}

/**Creates a histogram in which every unique value gets its own bin.
 * Useful for histograms where the distribution is known to be discrete over
 * a small set of values.
 *
 * Hint:  Since this class inherits from BarPlot, BarPlot.centers will provide
 * a list of the unique values found.  This can be used to label the X
 * axis.
 */
class UniqueHistogram : BarPlot {

    /**The total count of this histogram.*/
    immutable uint nElem;

    private HistType countsOrProbs = HistType.Counts;

    private this(double[] x, double[] y, double width, uint nElem) {
        this.nElem = nElem;
        super(x, y, width);
    }

    /**Create a UniqueHistogram.  R must be an input range with elements
     * implicitly convertible to double.  The width of each bin will be
     * widthFactor times the minimum distance between unique values. widthFactor
     * must be > 0 and <= 1.
     */
    static UniqueHistogram opCall(R)(R nums, double widthFactor = 0.8)
    if(isInputRange!R && isNumeric!(ElementType!R)) {
        enforce(widthFactor > 0 && widthFactor <= 1,
            "widthFactor must be > 0 and <= 1.");

        alias ElementType!R E;

        uint nElem;
        uint[double] counts;
        foreach(num; nums) {
            auto ptr = num in counts;
            if(ptr is null) {
                counts[num] = 1;
            } else {
                (*ptr)++;
            }
            nElem++;
        }

        auto possibleValues = counts.keys;
        sort(possibleValues);
        double minDiff = double.infinity;
        foreach(i; 1..possibleValues.length) {
            minDiff = min(minDiff, possibleValues[i] - possibleValues[i - 1]);
        }

        auto heights = new double[possibleValues.length];
        foreach(i, val; possibleValues) {
            heights[i] = counts[val];
        }

        return new typeof(this)
            (possibleValues, heights, minDiff * widthFactor, nElem);
    }

    /**Set whether this histogram displays counts or probabilities.*/
    void histType(HistType newType)  {
        if(newType == countsOrProbs) {
            return;
        } else if(newType == HistType.Counts) {
            scaleHeights(nElem);
        } else if(newType == HistType.Probability) {
            scaleHeights(1.0 / nElem);
        } else {
            assert(0);
        }

        countsOrProbs = newType;
    }
}

/**Class for drawing a heat map.*/
class HeatMap : Plot {
    private double[][] values;
    private double minVal;
    private double maxVal;
    private uint _nRows;
    private uint _nCols;

    private this() {
        // Set default colors.
        _coldColor = getColor(0, 0, 255);
        _hotColor = getColor(255, 0, 0);
    }

    private Color getCellColor(double val) {
        immutable diff = maxVal - minVal;
        val -= minVal;
        val /= diff;
        immutable compl = 1.0 - val;

        // Bug 4445:  roundTo!ubyte(255.0) throws.
        immutable red = cast(ubyte) roundTo!uint(
            _coldColor.r * compl + _hotColor.r * val);
        immutable green = cast(ubyte) roundTo!uint(
            _coldColor.g * compl + _hotColor.g * val);
        immutable blue = cast(ubyte) roundTo!uint(
            _coldColor.b * compl + _hotColor.b * val);

        return getColor(red, green, blue);
    }

    protected void heatMapDefaultBounds() {
        enforceRectangular();

        _nRows = values.length;
        if(values.length > 0) {
            _nCols = values[0].length;
        }

        leftLim = 0.5;
        rightLim = nCols + 0.5;
        lowerLim = 0.5;
        upperLim = nRows + 0.5;
    }

    protected void setMinMax() {
        minVal = double.infinity;
        maxVal = -double.infinity;

        foreach(row; values) foreach(val; row) {
            minVal = min(minVal, val);
            maxVal = max(maxVal, val);
        }
    }

    protected void enforceRectangular() {
        foreach(row; values) {
            enforce(row.length == values[0].length,
                "HeatMap matrices must be rectangular.");
        }
    }

    protected override void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        immutable cellWidth = (rightLim - leftLim) / nCols;
        immutable cellHeight = (upperLim - lowerLim) / nRows;

        if(nRows < 1 || nCols < 1) {
            return;
        }

        mixin(toPixels);
        double lastRowStop = toPixelsY(upperLim);
        foreach(row; 0..nRows) {
            immutable rowStop = toPixelsY(upperLim - cellHeight * (row + 1));
            scope(exit) lastRowStop = rowStop;

            double lastColStop = toPixelsX(leftLim);
            foreach(col; 0..nCols) {
                immutable colStop = toPixelsX(cellWidth * (col + 1) + leftLim);
                scope(exit) lastColStop = colStop;

                auto color = getCellColor(values[row][col]);
                auto rect = PlotRect(lastColStop, lastRowStop,
                    colStop - lastColStop, rowStop - lastRowStop);

                auto brush = form.getBrush(color);
                scope(exit) doneWith(brush);
                auto pen = form.getPen(color, 1);
                scope(exit) doneWith(pen);

                form.fillClippedRectangle(brush, rect);
                form.drawClippedRectangle(pen, rect);
            }
        }
    }

    private Color _coldColor;
    private Color _hotColor;

    /** The color to use for small values.*/
    final Color coldColor()() {
        return _coldColor;
    }

    /// Setter
    final This coldColor(this This)(Color newColor) {
        _coldColor = newColor;
        return cast(This) this;
    }

    /** The color to use for large values.*/
    final Color hotColor()() {
        return _hotColor;
    }

    /// Setter.
    final This hotColor(this This)(Color newColor) {
        _hotColor = newColor;
        return cast(This) this;
    }

    /**Create a heat map from a matrix represented as a range of ranges.
     * The matrix must be rectangular.  The elements of the ranges must
     * be implicitly convertible to double.
     */
    static HeatMap opCall(R)(R data)
    if(isInputRange!R && isInputRange!(ElementType!R) &&
       is(ElementType!(ElementType!(R)) : double)) {
        auto ret = new typeof(this);
        foreach(row; data) {
            ret.values ~= toDoubleArray(row);
        }

        ret.heatMapDefaultBounds();
        ret.setMinMax();
        return ret;
    }

    ///
    final uint nRows()  {
        return _nRows;
    }

    ///
    final uint nCols()  {
        return _nCols;
    }
}

/**Creates a heat map representing the density of a 2-d probability
 * distribution.  This is useful when you want to visualize a joint
 * probability distribution but the sample size is so large that a
 * scatter plot would have an overwhelming number of points.
 */
class HeatScatter : HeatMap {
    private double cellWidth;
    private double cellHeight;

    private OutOfBounds outOfBoundsBehavior = OutOfBounds.Throw;

    /**Create a HeatScatter.  x, y must be forward ranges with elements
     * implicitly convertible to double, and must have the same lengths.
     */
    static
    HeatScatter opCall(R1, R2)(R1 x, R2 y, uint nRows = 10, uint nCols = 10)
    if(isForwardRange!R1 && isForwardRange!R2 &&
       is(ElementType!R1 : double) && is(ElementType!R2 : double)) {
        double xMin = double.infinity;
        double xMax = -double.infinity;
        uint xLen;
        foreach(num; x.save) {
            xLen++;
            xMin = min(num, xMin);
            xMax = max(num, xMax);
        }

        double yMin = double.infinity;
        double yMax = -double.infinity;
        uint yLen;
        foreach(num; y.save) {
            yLen++;
            yMin = min(num, yMin);
            yMax = max(num, yMax);
        }

        enforce(xLen == yLen,
            "Can't make HeatScatter when x.length != y.length.");
        return opCall(x, y, nRows, nCols, xMin, xMax, yMin, yMax);
    }

    /**Create a HeatScatter with pre-specified bounds.  x, y must be forward
     * ranges with elements implicitly convertible to double, and must have the
     * same lengths.
     */
    static
    HeatScatter opCall(R1, R2)(R1 x, R2 y, uint nRows, uint nCols,
    double xMin, double xMax, double yMin, double yMax,
    OutOfBounds boundsBehavior = OutOfBounds.Throw)
    if(isForwardRange!R1 && isForwardRange!R2 &&
       is(ElementType!R1 : double) && is(ElementType!R2 : double)) {

        auto ret = opCall(nRows, nCols, xMin, xMax, yMin, yMax, boundsBehavior);

        double maxVal = 0;
        while(!x.empty && !y.empty) {
            scope(exit) {
                x.popFront();
                y.popFront();
            }

            ret.put(x.front(), y.front());
        }

        enforce(x.empty && y.empty,
            "Can't make HeatScatter when x.length != y.length.");
        return ret;
    }

    /**Create a blank HeatScatter to fill in using the put() method.
     *
     * Note:  This is a template only because templates can't be overloaded
     * against regular functions.
     */
    static
    HeatScatter opCall(I)(I nRows, uint nCols,
        double xMin, double xMax, double yMin, double yMax,
        OutOfBounds boundsBehavior = OutOfBounds.Throw) {
        enforce(nRows > 0 && nCols > 0,
            "Can't make a heat scatter with 0 rows or columns.");

        enforce(xMax > xMin, "xMax must be > xMin.");
        enforce(yMax > yMin, "yMax must be > yMin.");

        auto grid = new double[][](nRows, nCols);
        foreach(row; grid) foreach(ref elem; row) {
            elem = 0;
        }

        auto ret = new typeof(return);
        ret.boundsBehavior = boundsBehavior;
        immutable cellWidth = (xMax - xMin) / nCols;
        immutable cellHeight = (yMax - yMin) / nRows;
        ret.cellWidth = cellWidth;
        ret.cellHeight = cellHeight;
        ret.values = grid;
        ret._nRows = nRows;
        ret._nCols = nCols;
        ret.minVal = 0;
        ret.maxVal = 0;
        ret.leftLim = xMin;
        ret.rightLim = xMax;
        ret.lowerLim = yMin;
        ret.upperLim = yMax;
        return ret;
    }

    /**Add an element to the plot.*/
    This put(this This)(double x, double y) {
        bool inBounds() {
            return (x >= leftLim && x <= rightLim && y >= lowerLim &&
            y <= upperLim);
        }

        if(outOfBoundsBehavior == OutOfBounds.Throw) {
            enforce(inBounds(), "Point out of bounds in HeatScatter.");
        } else if(!inBounds()) {
            return cast(This) this;
        }

        uint xCoord = to!uint((x - leftLim) / cellWidth);
        if(xCoord == nCols) {
            xCoord--;
        }

        uint yCoord = nRows - to!uint((y - lowerLim) / cellHeight) - 1;
        if(yCoord == uint.max) {
            yCoord = 0;
        }

        values[yCoord][xCoord]++;
        maxVal = max(maxVal, values[yCoord][xCoord]);

        return cast(This) this;
    }

    /**Add another HeatScatter's data to this.  The boundaries and row and
     * column counts must be the same.  The settings from this HeatScatter are
     * preserved.
     */
    This put(this This)(const HeatScatter rhs) {
        if(rhs is null) {
            return cast(This) this;
        }
        enforce(this.leftLim == rhs.leftLim && this.rightLim == rhs.rightLim &&
                this.upperLim == rhs.upperLim && this.lowerLim == rhs.lowerLim
                && this._nRows == rhs._nRows && this._nCols == rhs._nCols,
        "Cannot combine two HeatScatters w/ different bounds or row/column #s.");

        foreach(row; 0.._nRows) foreach(col; 0.._nCols) {
            this.values[row][col] += rhs.values[row][col];
            this.maxVal = max(this.values[row][col], this.maxVal);
        }

        return cast(This) this;
    }

    /**Determine whether this object throws or ignores if it receives a number
     * outside its bounds via put.
     */
    void boundsBehavior(OutOfBounds behavior) {
        outOfBoundsBehavior = behavior;
    }
}


/**Class for drawing a scatter plot.*/
class ScatterPlot : Plot {
    private double[] x;
    private double[] y;

    protected void addFudgeFactors() {
        // Add fudge factors to bounds to make points not appear off the chart.
        immutable horizFudge = (upperLim - lowerLim) * 0.03;
        immutable verticalFudge = (rightLim - leftLim) * 0.03;
        leftLim -= verticalFudge;
        rightLim += verticalFudge;
        upperLim += horizFudge;
        lowerLim -= horizFudge;
    }

    override void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        enforce(x.length == y.length);  // Should have already been checked.

        if(x.length < 1) {
            return;
        }

        mixin(toPixels);

        auto font = getFont(plot2kill.util.defaultFont,
            10 + Figure.fontSizeAdjust);
        scope(exit) doneWith(font);

        string writeThis = [cast(immutable) _pointSymbol];

        immutable measure = form.measureText(writeThis, font);
        immutable rectWidth = measure.width;
        immutable rectHeight = measure.height;

        foreach(i; 0..x.length) {
            immutable curX = toPixelsX(x[i]);
            immutable curY = toPixelsY(y[i]);
            auto rect = PlotRect(
                curX - rectWidth / 2,
                curY - rectHeight / 2,
                rectWidth,
                rectHeight
            );

            form.drawClippedText(writeThis, font, _pointColor, rect);
        }
    }

    private Color _pointColor;
    private char _pointSymbol = 'x';


    /**The color of each point on the plot.*/
    final Color pointColor()() {
        return _pointColor;
    }

    /// Setter.
    final This pointColor(this This)(Color newColor) {
        _pointColor = newColor;
        return cast(This) this;
    }

    /**The symbol that should be used on the plot.  x and o work pretty well.
     * The default is x.
     */
    final char pointSymbol()() {
        return _pointSymbol;
    }

    /// Setter
    final This pointSymbol(this This)(char newSymbol) {
        _pointSymbol = newSymbol;
        return cast(This) this;
    }

    this() {
        _pointColor = getColor(0, 0, 0);
    }


    /**Factory method for creating a ScatterPlot.  x and y must both be
     * input ranges of the same length, with elements implicitly convertible
     * to doubles.  Note that they are copied inside the factory, so changes
     * to the original ranges after calling this factory will not affect the
     * plot.
     */
    static ScatterPlot opCall(R1, R2)(R1 x, R2 y)
    if(isInputRange!R1 && is(ElementType!R1 : double) &&
       isInputRange!R2 && is(ElementType!R2 : double)) {

        auto ret = new ScatterPlot;
        constructXYGraph(x, y, ret);

        ret.addFudgeFactors();
        return ret;
    }

    /**Convenience factory that produces a ScatterPlot with a default X
     * axis numbered 1, 2, ..., N where N is the number of points.  Mostly
     * useful for quick and dirty plots.
     */
    static ScatterPlot opCall(R)(R y)
    if(isInputRange!R && is(ElementType!R : double)) {
        auto ret = new ScatterPlot;
        ret.y = toDoubleArray(y);
        ret.x = new double[ret.y.length];

        foreach(i, ref elem; ret.x) {
            elem = i + 1;
        }

        fixXYGraphBounds(ret);
        ret.addFudgeFactors();

        return ret;
    }
}

/**Class for drawing a line graph, i.e. a set of points connected by lines.*/
class LineGraph : Plot {
    private double[] x;
    private double[] y;
    private double[] lowerErrors;
    private double[] upperErrors;

    private enum defaultErrorWidth = 0.05;
    private double _errorWidth = defaultErrorWidth;

    protected void fixBounds() {
        this.leftLim = reduce!min(double.infinity, this.x);
        this.rightLim = reduce!max(-double.infinity, this.x);

        this.upperLim = -double.infinity;
        this.lowerLim = double.infinity;
        foreach(i, yCoord; this.y) {
            if(this.lowerErrors.length) {
                this.lowerLim = min(this.lowerLim, yCoord - this.lowerErrors[i]);
            } else {
                this.lowerLim = min(this.lowerLim, yCoord);
            }
            if(this.upperErrors.length) {
                this.upperLim = max(this.upperLim, yCoord + this.upperErrors[i]);
            } else {
                this.upperLim = max(this.upperLim, yCoord);
            }
        }

        if(this.lowerErrors.length || this.upperErrors.length) {
            // Dont' cut off error bars.
            immutable yPad = (this.upperLim - this.lowerLim) * 0.01;
            immutable xPad = (this.rightLim - this.leftLim) * _errorWidth;
            this.leftLim -= xPad;
            this.rightLim += xPad;
            this.upperLim += yPad;
            this.lowerLim -= yPad;
        }
    }

    protected void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        enforce(x.length == y.length);  // Should have already been checked.

        if(x.length < 2) {
            return;
        }

        mixin(toPixels);
        mixin(drawErrorMixin);

        immutable absErrorWidth = _errorWidth * (rightLim - leftLim);
        auto errorPen = form.getPen(getColor(0, 0, 0));
        scope(exit) doneWith(errorPen);

        double lastX = toPixelsX(x[0]);
        double lastY = toPixelsY(y[0]);

        void doErrors(uint index) {
            if(lowerErrors.length) {
                drawErrorBar(
                    errorPen, x[index], y[index],
                        y[index] - lowerErrors[index], absErrorWidth
                );
            }
            if(upperErrors.length) {
                drawErrorBar(
                    errorPen, x[index], y[index],
                        y[index] + upperErrors[index], absErrorWidth
                );
            }
        }

        auto pen = form.getPen(_lineColor, _lineWidth);
        scope(exit) doneWith(pen);

        foreach(i; 1..x.length) {
            immutable curX = toPixelsX(x[i]);
            immutable curY = toPixelsY(y[i]);

            form.drawClippedLine(pen, PlotPoint(lastX, lastY), PlotPoint(curX, curY));
            lastX = curX;
            lastY = curY;
        }

        foreach(i; 0..x.length) {
            doErrors(i);
        }
    }

    private Color _lineColor;
    private uint _lineWidth = 1;

    /**The color of the line.  The default is black.*/
    final Color lineColor()() {
        return _lineColor;
    }

    /// Setter
    final This lineColor(this This)(Color newColor) {
        _lineColor = newColor;
        return cast(This) this;
    }

    /**The width of the line.  The default is 1.*/
    final uint lineWidth()() {
        return _lineWidth;
    }

    /// Setter
    final This lineWidth(this This)(uint newWidth) {
        _lineWidth = newWidth;
        return cast(This) this;
    }

    /**Error bar width, relative to the total width of the plot.  Must be
     * between 0 and 1.  If it's out of bounds, it will be set to the default
     * of 0.05.  If no error bars are to be drawn, this option is ignored.
     */
    final double errorWidth()() {
        return _errorWidth;
    }

    /// Setter
    final This errorWidth(this This)(double newWidth) {
        if(!(newWidth >= 0 && newWidth <= 1)) {
            _errorWidth = defaultErrorWidth;
        } else {
            _errorWidth = newWidth;
        }

        fixBounds();
        return cast(This) this;
    }

    private this() {
        _lineColor = getColor(0, 0, 0);
    }

    /**Factory method for creating a LineGraph.  x and y must both be
     * input ranges of the same length, with elements implicitly convertible
     * to doubles.  Note that they are copied inside the factory, so changes
     * to the original ranges after calling this factory will not affect the
     * plot.
     */
    static LineGraph opCall(R1, R2)(R1 x, R2 y)
    if(isInputRange!R1 && is(ElementType!R1 : double) &&
       isInputRange!R2 && is(ElementType!R2 : double)) {

        auto ret = new LineGraph;
        constructXYGraph(x, y, ret);
        ret.fixBounds();
        return ret;
    }

    /**Convenience factory method that produces a LineGraph with a default
     * X axis numbered 1, 2, ..., N, where N is the number of data points,
     * and no error bars.  This is mostly useful for quick and dirty plots.
     */
    static LineGraph opCall(R)(R y)
    if(isInputRange!R && is(ElementType!R : double)) {
        auto ret = new LineGraph;
        ret.y = toDoubleArray(y);
        ret.x = new double[ret.y.length];

        foreach(i, ref elem; ret.x) {
            elem = i + 1;
        }
        ret.fixBounds();
        return ret;
    }

    /**Create a LineGraph with error bars.  lowerErrors and upperErrors
     * must be input ranges with elements implicitly convertible to double for
     * error bars to be shown.  Any other value, such as null or 0, will result
     * in no error bars being shown.  Therefore, to only show, for example,
     * upper erros, simply pass in null or 0 for the lower errors.
     *
     * To draw symmetric error bars, simply pass in the same range for
     * lowerErrors and upperErrors.  However, note that if you do this,
     * the range will need to be a forward range, not an input range.
     */
    static LineGraph opCall(R1, R2, R3, R4)
    (R1 x, R2 y, R3 lowerErrors, R4 upperErrors) {
        auto ret = new typeof(return);
        ret.x = toDoubleArray(x);
        ret.y = toDoubleArray(y);

        enforce(ret.x.length == ret.y.length,
            "x, y must have same length for line/scatter graph.");

        static if(isForwardRange!R3) {
            ret.lowerErrors = toDoubleArray(lowerErrors.save);
        } else static if(isInputRange!R3) {
            ret.lowerErrors = toDoubleArray(lowerErrors);
        }

        static if(isForwardRange!R4) {
            ret.upperErrors = toDoubleArray(upperErrors.save);
        } else static if(isInputRange!R4) {
            ret.upperErrors = toDoubleArray(upperErrors);
        }

        enforce(ret.upperErrors.length == 0 || ret.upperErrors.length ==
            ret.x.length, "Length of upperErrors must equal number of points.");
        enforce(ret.lowerErrors.length == 0 || ret.lowerErrors.length ==
            ret.x.length, "Length of lowerErrors must equal number of points.");

        if(ret.lowerErrors.length == 0 && ret.upperErrors.length == 0) {
            sort!"a.at!0 < b.at!0"(zip(ret.x, ret.y));
        } else if(ret.lowerErrors.length == 0) {
            sort!"a.at!0 < b.at!0"(zip(ret.x, ret.y, ret.upperErrors));
        } else if(ret.upperErrors.length == 0) {
            sort!"a.at!0 < b.at!0"(zip(ret.x, ret.y, ret.lowerErrors));
        } else {
            sort!"a.at!0 < b.at!0"(
                zip(ret.x, ret.y, ret.lowerErrors, ret.upperErrors));
        }

        ret.fixBounds();
        return ret;
    }

    /**Scale this object by a factor of scaleFactor in the X direction.
     * This is useful for getting it onto the same scale as another plot.
     */
    void scaleX(double scaleFactor) {
        enforce(isFinite(scaleFactor), "Can't scale by infinity or NaN.");
        x[] *= scaleFactor;
        fixBounds();
    }

    /**Scale this object by a factor of scaleFactor in the Y direction.
     * This is useful for getting it onto the same scale as another plot.*/
    void scaleY(double scaleFactor) {
        enforce(isFinite(scaleFactor), "Can't scale by infinity or NaN.");
        y[] *= scaleFactor;
        fixBounds();
    }

    /**Shift this graph by shiftBy units in the X direction.
     * This is useful for getting it onto the same scale as another plot.
     */
    void shiftX(double shiftBy) {
        enforce(isFinite(shiftBy), "Can't shift by infinity or NaN.");
        x[] += shiftBy;
        fixBounds();
    }

    /**Shift this graph by shiftBy units in the Y direction.
     * This is useful for getting it onto the same scale as another plot.
     */
    void shiftY(double shiftBy) {
        enforce(isFinite(shiftBy), "Can't shift by infinity or NaN.");
        y[] += shiftBy;
        fixBounds();
    }
}

private void constructXYGraph(T, R1, R2)(R1 x, R2 y, T ret) {
    ret.x = toDoubleArray(x);
    ret.y = toDoubleArray(y);

    enforce(ret.x.length == ret.y.length,
        "x, y must have same length for line/scatter graph.");

    sort!"a.at!0 < b.at!0"(zip(ret.x, ret.y));
    fixXYGraphBounds(ret);
}

private void fixXYGraphBounds(G)(G graph) {
    graph.lowerLim = reduce!min(double.infinity, graph.y);
    graph.upperLim = reduce!max(-double.infinity, graph.y);
    graph.leftLim = reduce!min(double.infinity, graph.x);
    graph.rightLim = reduce!max(-double.infinity, graph.x);

    /* Weird things happen when a graph has zero width or height.  Add fudge
     * factors to correct this.
     */
    with(graph) {
        if(lowerLim == upperLim) {
            lowerLim = nextafter(lowerLim, -double.infinity);
            upperLim = nextafter(upperLim, double.infinity);
        }

        if(leftLim == rightLim) {
            leftLim = nextafter(leftLim, -double.infinity);
            rightLim = nextafter(rightLim, double.infinity);
        }
    }
}

/**Plot a callable object on a range of values.*/
class ContinuousFunction : LineGraph {
    private enum string setupClass = q{
        auto ret = new ContinuousFunction;

        enforce(upperLim > lowerLim,
            "Can't do a function plot if upperLim <= lowerLim.");
        enforce(nEvals >= 2, "Can't do function plot with < 2 evals.");

        immutable diff = upperLim - lowerLim;
        immutable width = diff / (nEvals - 1);
        auto x = new double[nEvals];
        auto y = new double[nEvals];

        foreach(i; 0..nEvals) {
            x[i] = i * width + lowerLim;
            y[i] = callable(x[i]);
        }

        ret.x = x;
        ret.y = y;
        fixXYGraphBounds(ret);
        return ret;
    };

    /**Create a ContinuousFunction.  C is any callable type mapping a floating
     * point number to a number.  lowerLim is the lower limit of the plot.
     * upperLim is the upper limit of the plot.  nEvals is the number of
     * evalutations to perform.  The default is 1000.  More evaluations means
     * more accuracy but more computational intensity.
     */
    static ContinuousFunction opCall(C)(
        scope C callable,
        double lowerLim,
        double upperLim,
        uint nEvals = 1000
    ) if(is(typeof(C.init(2.0)) : double)) {
        // For some reason doing return opCall!callable doesn't work.
        // Using mixin instead.
        mixin(setupClass);
    }

    /**Create a ContinuousFunction using a template alias parameter instead of
     * a callable object.
     *
     * Note:  This function is given an name instead of opCall because DMD
     * thinks you're trying to instantiate a class if you do
     * ContinuousFunction!fun(...).
     */
    static ContinuousFunction fromAlias(alias callable)(
        double lowerLim,
        double upperLim,
        uint nEvals = 1000
    ) if(is(typeof(callable(2.0)) : double)) {
        mixin(setupClass);
    }

}

/**Plot a callable object on a range of values.*/
class DiscreteFunction : BarPlot {

    private this(double[] x, double[] y) {
        super(x, y, 1);
    }

    /**Create a DiscreteFunction. C is any callable type mapping an integer
     * to a number.  lowerLim is the lower limit of the plot.
     * upperLim is the upper limit of the plot.
     */
    static DiscreteFunction opCall(C)(
        scope C callable,
        int lowerLim,
        int upperLim,
    ) if(is(typeof(C.init(2)) : double)) {
        enforce(upperLim > lowerLim,
            "Can't do a function plot if upperLim <= lowerLim.");

        static if(is(typeof(C.opCall))) {
            alias ParameterTypeTuple!(C.opCall)[0] I;
        } else {
            alias ParameterTypeTuple!(C)[0] I;
        }

        I input = to!I(lowerLim);
        double[] x = new double[upperLim - lowerLim + 1];
        double[] y = new double[upperLim - lowerLim + 1];

        foreach(int index; 0..x.length) {
            x[index] = lowerLim + index;
            y[index] = callable(input);
            input++;
        }

        auto ret = new typeof(return)(x, y);
        ret.fixBounds();
        return ret;
    }

    /**Create a DiscreteFunction using a template alias parameter instead of
     * a callable object.
     *
     * Note:  This function is given an name instead of opCall because DMD
     * thinks you're trying to instantiate a class if you do
     * ContinuousFunction!fun(...).
     */
    static DiscreteFunction fromAlias(alias callable)(
        int lowerLim,
        int upperLim,
    ) if(is(typeof(callable(2)) : double)) {
        enforce(upperLim > lowerLim,
            "Can't do a function plot if upperLim <= lowerLim.");

        int input = lowerLim;
        double[] x = new double[upperLim - lowerLim + 1];
        double[] y = new double[upperLim - lowerLim + 1];

        foreach(int index; 0..x.length) {
            x[index] = lowerLim + index;
            y[index] = callable(input);
            input++;
        }

        auto ret = new typeof(return)(x, y);
        ret.fixBounds();
        return ret;
    }
}

// Above was relatively basic plots.  Below is more specialized statistical
// plots.

/**Plots a ROC curve, or a curve with sensitivity on the Y-axis
 * and 1 - specificity on the X-axis.  This is a useful metric for
 * determining how well a test statistic discriminates between two classes.
 * The following assumptions are made in this implementation:
 *
 * 1.  For some cutoff value c and test statistic T, your decision rule is of
 *     the form "Class A if T larger than c, Class B if T smaller than c".
 *
 * 2.  In the case of ties, i.e. if class A and class B both have an identical
 *     value, linear interpolation is used.  This is because changing the
 *     value of c infinitesimally will change both sensitivity and specificity
 *     in these cases.
 */
class RocCurve : LineGraph {
private:
    double _auroc;

    this() {
        super();
    }

public:
    /**Create a RocCurve.  classATs are the test statistics that are
     * "supposed" to be bigger, classBTs are the test statistics that are
     * "supposed to be smaller.  Both R1 and R2 must be input ranges with
     * elements implicitly convertible to double.
     */
    static RocCurve opCall(R1, R2)(R1 classATs, R2 classBTs)
    if(isNumeric!(ElementType!R1) && isNumeric!(ElementType!R2)) {
        // Shamelessly cut-and-pasted and modified from dstats.

        auto classA = array(classATs);
        auto classB = array(classBTs);
        sort(classA);
        sort(classB);

        // Start cutoff at -infinity, such that we get everything in class A, i.e.
        // perfect specificity, zero sensitivity.  We arbitrarily define class B
        // as our "positive" class.
        double tp = 0, tn = classA.length, fp = 0, fn = classB.length;
        double[2] lastPoint = 0;

        Unqual!(CommonType!(ElementType!R1, ElementType!R2)) currentVal;

        ElementType!R1 popA() {
            tn--;
            fp++;
            auto ret = classA.front();
            classA.popFront();
            return ret;
        }

        ElementType!R2 popB() {
            fn--;
            tp++;
            auto ret = classB.front();
            classB.popFront();
            return ret;
        }

        double area = 0;
        double[] x = [0.0];
        double[] y = [0.0];
        while(!classA.empty && !classB.empty) {
            if(classA.front() < classB.front()) {
                currentVal = popA();
            } else {
                currentVal = popB();
            }

            // Handle ties.
            while(!classA.empty && classA.front() == currentVal) {
                popA();
            }

            while(!classB.empty && classB.front() == currentVal) {
                popB();
            }

            double[2] curPoint;
            curPoint[0] = 1.0 - tn / (fp + tn);
            curPoint[1] = tp / (tp + fn);

            x ~= curPoint[0];
            y ~= curPoint[1];

            immutable xDist = curPoint[0] - lastPoint[0];
            area += xDist * lastPoint[1];  // Rectangular part.
            area += xDist * 0.5 * (curPoint[1] - lastPoint[1]);  // Triangular part.
            lastPoint[] = curPoint[];
        }

        if(classA.length > 0 && classB.length == 0) {
            // Then we already have a sensitivity of 1, move straight to the right
            // to the point (1, 1).

            immutable xDist = 1 - lastPoint[0];
            area += xDist * lastPoint[1];  // Rectangular part.
            area += xDist * 0.5 * (1 - lastPoint[1]);  // Triangular part.
        }

        x ~= 1;
        y ~= 1;

        auto ret = new typeof(return)();
        ret._auroc = area;
        ret.x = x;
        ret.y = y;
        fixXYGraphBounds(ret);
        return ret;
    }

    /**Returns the area under the ROC curve.*/
    final double auroc() const pure nothrow  {
        return _auroc;
    }

    /**Default title is the area under the curve.  Default x label is
     * "1 - Specificity".  Default y label is "Sensitivity".
     */
    Figure toLabeledFigure()  {
        auto ret = toFigure;
        ret.title = "AUROC = " ~ to!string(auroc);
        ret.xLabel = "1 - Specificity";
        ret.yLabel = "Sensitivity";
        return ret;
    }
}

unittest {
    // Values worked out by hand on paper.  If you don't believe me, work
    // them out yourself.
    auto foo = RocCurve([4,5,6], [1,2,3]);
    assert(foo.auroc == 1);

    foo = RocCurve([8,6,7,5,3,0,9], [3,6,2,4,3,6]);
    assert(approxEqual(foo.auroc, 0.6904762));

    foo = RocCurve([2,7,1,8,2,8,1,8], [3,1,4,1,5,9,2,6]);
    assert(approxEqual(foo.auroc, 0.546875));
}

/**Plots the quantiles of a set of data on the Y axis against the theoretical
 * qualtiles or the quantiles of another set of data on the X axis.
 */
class QQPlot : ScatterPlot {
    private this() {
        super();
        _lineColor = getColor(255, 0, 0);
    }

    protected void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        super.drawPlot(
            form, leftMargin, topMargin, plotWidth, plotHeight
        );

        // Draw line that indicates identical distributions.
        if(max(lowerLim, leftLim) < min(upperLim, rightLim)) {
            mixin(toPixels);

            auto pen = form.getPen(_lineColor, _lineWidth);
            scope(exit) doneWith(pen);

            immutable lowerX = toPixelsX(max(lowerLim, leftLim));
            immutable lowerY = toPixelsY(max(lowerLim, leftLim));
            immutable upperX = toPixelsX(min(upperLim, rightLim));
            immutable upperY = toPixelsY(min(upperLim, rightLim));

            form.drawClippedLine(
                pen,
                PlotPoint(lowerX, lowerY),
                PlotPoint(upperX, upperY)
            );
        }
    }

    private Color _lineColor;

    /**The color of the y = x line that indicates identical distributions.
     * The default is red.
     */
    final Color lineColor()() {
        return _lineColor;
    }

    /// Setter
    final This lineColor(this This)(Color newColor) {
        _lineColor = newColor;
        return cast(This) this;
    }

    private double _lineWidth = 2;

    /**The width of the line that indicates identical distributions.
     * The default is 2.
     */
    final double lineWidth()() {
        return _lineWidth;
    }

    /// Setter.
    final This lineWidth(this This)(double newWidth) {
        _lineWidth = newWidth;
        return cast(This) this;
    }

    /**Create a QQPlot.  dataRange must be an input range with elements
     * implicitly convertible to doubles.  quantileFunction must be a
     * callable (function pointer, delegate, functor, etc.) mapping any
     * number between 0 and 1 to its quantile.
     *
     * Examples:
     * ---
     * auto norms = randArray!rNorm(100, 0, 1);
     * auto theoretical = paramFunctor!invNormalCDF(0, 1);
     * auto fig = new Figure(
     *     QQPlot(norms, theoretical)
     * );
     * fig.showAsMain();
     * ---
     */
    static QQPlot opCall(R, C)(R dataRange, C quantileFunction)
    if(is(typeof(C.init(2.0)) : double) && isInputRange!R &&
    is(ElementType!R : double)) {
        auto ret = new QQPlot;

        ret.y = toDoubleArray(dataRange);
        sort(ret.y);
        immutable double N = ret.y.length + 1.0;

        ret.x = new double[ret.y.length];
        foreach(i, ref elem; ret.x) {
            elem = quantileFunction((i + 1) / N);
        }

        fixXYGraphBounds(ret);
        ret.addFudgeFactors();
        return ret;
    }

    /**Default x label is "Theoretical Quantiles".  Default y label is
     * "Empirical Quantiles".
     */
    Figure toLabeledFigure() {
        auto ret = toFigure;
        ret.xLabel = "Theoretical Quantiles";
        ret.yLabel = "Empirical Quantiles";
        return ret;
    }
}
