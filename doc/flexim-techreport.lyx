#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass paper
\begin_preamble
\usepackage{graphicx}
\usepackage{color}
\usepackage{moreverb}
\usepackage{multirow}
\usepackage{makeidx}
\usepackage{array}
\usepackage{longtable}


\renewcommand{\baselinestretch}{1}
\end_preamble
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing onehalf
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Flexim: An Evolvable Simulator to Evaluate Multicore Processors
\end_layout

\begin_layout Author
Min Cai, Zhimin Gu
\end_layout

\begin_layout Institution
Beijing Institute of Technology, Beijing 100081, P.R.China
\end_layout

\begin_layout Abstract
Architectural simulators are critical for successful multicore processor
 research nowadays.
 Most of the existing simulators are written in C or C++ for speed consideration
s, and the modeled computer structures and functionalities are intermixed,
 which are very difficult to maintain and evolve.
 Many simulators come and go with short longevity, because they can not
 fulfill the needs of studying fast-paced evolving computer architectures.
 In this paper, we take a modern approach and treat the evolvability of
 the simulator as a first-class citizen when we are constructing our Flexim
 simulator.
 
\end_layout

\begin_layout Abstract
Flexim's functionalities are clearly partitioned into three categories:
 functional simulation, performance smulation and supporting infrastructure.
 It models a five-stage out-of-order issue processor core, directory-based
 two-level coherent cache hierarchy, and interfaces to external interconnection
 and DRAM controller simulators.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Flexim
\begin_inset Foot
status open

\begin_layout Plain Layout
For the latest Flexim code, please visit the project's website on Github:
 
\begin_inset CommandInset href
LatexCommand href
target "http://github.com/mcai/flexim"

\end_inset

.
 
\end_layout

\end_inset

 is an open-source, modular and highly configurable architectural simulator
 for evaluating emerging multicore processors.
 Based on the past experience and guided by a few key software engineering
 concepts, it is developed from scratch in the object-oriented D system
 programing language to obtain good maintainability, reusability and modularity
 of the simulator code, and advocates further extensions via plugins.
 It can run statically compiled MIPS32 Little-Endian (LE) programs.
\end_layout

\begin_layout Subsection
Key Features
\end_layout

\begin_layout Enumerate
Architectural
\end_layout

\begin_deeper
\begin_layout Itemize
Simulation of a classic five-stage superscalar pipeline with out-of-order
 execution.
 
\end_layout

\begin_layout Itemize
Multi-level memory hierarchy with the directory-based MESI cache coherence
 protocol.
 
\end_layout

\begin_layout Itemize
Support for Syscall-emulation mode simulation (i.e., application only, no
 need to boot an OS).
 
\end_layout

\begin_layout Itemize
Correct execution of several state-of-the-art benchmark suites, e.g., wcet_bench,
 Olden and CPU2006.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Non-architectural
\end_layout

\begin_deeper
\begin_layout Itemize
Developed from scratch in the object-oriented system programming language
 D 2.0.
 Great efforts are made to advocate software engineering practices in the
 simulator construction.
 
\end_layout

\begin_layout Itemize
A powerful infrastructure that provides common functionalities such as eventing,
 logging and XML I/O.
 
\end_layout

\begin_layout Itemize
Pervasive use of XML-based I/O for architectural, workload and experiment
 configurations and statistics.
 
\end_layout

\begin_layout Itemize
Easy to use.
 No scripting.
 Only required are a statically compiled simulator executable and a few
 XML files.
 
\end_layout

\end_deeper
\begin_layout Standard
The whole development of the Flexim simulator encompasses three main categories
 of functionalities: functional simulation, performance simulation and the
 supporting infrastructure.
 
\end_layout

\begin_layout Standard
The rest of this technical report is structured as follows.
 Section 2 focuses on functional simulation.
 Section 3 elaborates on performance simulation.
 Section 4 focuses on the supporting infrastructure.
 And Section 5 provides the evaluation, limitations and future work of Flexim.
\end_layout

\begin_layout Section
Functional Simulation
\end_layout

\begin_layout Standard
Functional simulation encompasses the abilities to load and parse MIPS binaries,
 decode and execute instructions, and emulate system calls.
\end_layout

\begin_layout Subsection
ELF-Formatted MIPS Little-Endian Executable Loader
\end_layout

\begin_layout Standard
The Executable and Linkable Format (ELF) is a standard binary file format
 for Unix and Unix-like (such as Linux) systems.
 Each ELF file is made up of one ELF header, followed by file data.
 The file data can include:
\end_layout

\begin_layout Itemize
Program header table, describing zero or more segments
\end_layout

\begin_layout Itemize
Section header table, describing zero or more sections
\end_layout

\begin_layout Itemize
Data referred to by entries in the program header table or section header
 table
\end_layout

\begin_layout Standard
The segments contain information that is necessary for runtime execution
 of the file, while sections contain important data for linking and relocation.
 Each byte in the entire file is taken by no more than one section at a
 time, but there can be orphan bytes, which are not covered by a section.
 In the normal case of a Unix executable one or more sections are enclosed
 in one segment.
\end_layout

\begin_layout Standard
In Flexim, the tasks of loading and parsing of ELF files are done through
 the classes 
\family typewriter
ELFReader
\family default
 and 
\family typewriter
ELF32Binary
\family default
 and a few supporting code elements.
 Each process in Flexim is associated with one 
\family typewriter
ELF32Binary
\family default
 object.
\end_layout

\begin_layout Subsection
Instruction Decoding and Execution
\end_layout

\begin_layout Standard
In Flexim, there are two kinds of instructions, i.e., static instructions
 and dynamic instructions.
 A static instruction represents a decoded instruction that fetched from
 memory, and a dynamic instruction represents a dynamically-scheduled instructio
n.
 
\end_layout

\begin_layout Standard
Below are the details of types of the implemented MIPS32 instructions.
\end_layout

\begin_layout Subsection
System Call Emulation
\end_layout

\begin_layout Standard
System calls are the services that provided by the Linux kernel.
 To simulate MIPS32 LE/Linux applications, a few system calls are emulated
 for the correct execution of the whole wcet_bench benchmark suite, and
 mst and em3d from the Olden benchmark suite.
\end_layout

\begin_layout Section
Performance Simulation
\end_layout

\begin_layout Standard
Performance simulation encompasses the detailed simulation of out-of-order
 processor cores and multi-level memory hierarchies.
\end_layout

\begin_layout Subsection
Processor
\end_layout

\begin_layout Standard
As shown in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pipeline_arch"

\end_inset

, the simulated out-of-order pipeline is divided into five stages: fetch,
 decode/rename, issue, execute, and commit.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename processor.eps
	display false
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Overview of the Simulated Out-of-Order Processor Pipeline
\begin_inset CommandInset label
LatexCommand label
name "fig:pipeline_arch"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Cycle-Accurate Modeling of Pipeline Structures
\end_layout

\begin_layout Standard
Flexim supports the mix of SMT and CMP simulation.
 Some processor structures are shared among threads within a processor core,
 and others are private to each thread.
\end_layout

\begin_layout Standard
Flexim explicitly models the Reorder Buffer (
\family typewriter
ReorderBuffer
\family default
), the Issue Queue (
\family typewriter
IssueQueue
\family default
), the Load/Store Queue (
\family typewriter
LoadStoreQueue
\family default
), separate integer, floating-point and miscellaneous register files, register
 renaming, and the associated rename table.
\end_layout

\begin_layout Standard
The reorder buffer is modeled as a FIFO buffer.
 Its entries are pushed during instruction 
\family typewriter
dispatch()
\family default
 and are popped during instruction 
\family typewriter
commit()
\family default
.
 
\end_layout

\begin_layout Standard
The issue queue is modeled as an array of issue queue entries.
 Each issue queue entry (
\family typewriter
IssueQueueEntry
\family default
) can be in one of two states: either free(
\family typewriter
IssueQueueEntryState.FREE
\family default
) or already allocated(
\family typewriter
IssueQueueEntry.ALLOC
\family default
).
 Its entries are allocated at instruction 
\family typewriter
dispatch()
\family default
 and are released at 
\family typewriter
issue()
\family default
 and on branch mispredictions on 
\family typewriter
recoverReorderBuffer()
\family default
.
\end_layout

\begin_layout Standard
The integer, floating point and miscellaneous physical register files are
 modeled separately as 
\family typewriter
intRegFile
\family default
, 
\family typewriter
fpRegFile
\family default
 and 
\family typewriter
miscRegFile
\family default
, respectively.
 All of them contain an array of physical registers(
\family typewriter
PhysicalRegister
\family default
).
 Each of the physical registers can be in one of four states: 
\end_layout

\begin_layout Enumerate
the register is free (
\family typewriter
PhysicalRegisterState.FREE
\family default
),
\end_layout

\begin_layout Enumerate
the register has been allocated to an instruction but has not yet been written
 to (
\family typewriter
PhysicalRegisterState.ALLOC
\family default
),
\end_layout

\begin_layout Enumerate
the register is allocated to an instruction and the value has been written
 (
\family typewriter
PhysicalRegisterState.W
\family default
B),
\end_layout

\begin_layout Enumerate
the register is in the architectural state (
\family typewriter
PhysicalRegisterState.ARCH
\family default
).
\end_layout

\begin_layout Standard
Physical registers are allocated at the 
\family typewriter
dispatch()
\family default
 stage, and deallocated at 
\family typewriter
commit()
\family default
 and during branch mispredictions in 
\family typewriter
recoverReorderBuffer()
\family default
.
\end_layout

\begin_layout Standard
The integer, floating point and miscellaneous rename tables are modeled
 separately.
 They maintain the current mappings of each architectural register to a
 physical register.
\end_layout

\begin_layout Subsubsection
Details of the Processor model and Implementation
\end_layout

\begin_layout Standard
Threads within a core maintain separate program counters, but share the
 fetch unit and icache.
 Threads within a core share the available bandwidth in the front end including
 fetch, decode and rename.
 The time slice based fetch policy is implemented for the moment, more advanced
 policies such as icount is left for future work.
 Separate branch predictors are implemented per thread.
\end_layout

\begin_layout Standard
Each thread maintains its own rename table because it has its own set of
 architectural registers.
 After renaming, instructions from all threads are dispatched into the shared
 issue queue.
\end_layout

\begin_layout Standard
In the issue queue, instructions from all the threads participate in the
 instruction 
\family typewriter
wakeup()
\family default
 process and compete for the issue bandwidth in 
\family typewriter
selection()
\family default
.
 Instructions that are selected for issue continue to perform register file
 accesses.
 All the physical register files are shared among the threads.
 After register file accesses are done, instructions begin execution on
 the functional units, which are also shared among the threads.
\end_layout

\begin_layout Standard
Loads and stores access the shared dcache among the threads within a core.
 In order to maintain the correct orderings of memory accesses, the load/store
 queue (
\family typewriter
LoadStoreQueue
\family default
) is used.
 Separate load/store queue is maintained per thread, so that an unresolved
 address from one thread does not prevent loads in other threads from issuing.
\end_layout

\begin_layout Standard
After execution, instructions write back to the register files.
 Commitment (or retirement) is done in order for each thread out of the
 re-order buffers (
\family typewriter
ReorderBuffer
\family default
s).
 Separate reorder buffers are maintained per thread.
 
\end_layout

\begin_layout Subsection
Memory Hierarchy
\end_layout

\begin_layout Subsubsection
Internal Cache Structure and Cache Coherence
\end_layout

\begin_layout Standard
A two-level cache hierarchy is modeled for the moment.
 Cache coherence is enforced with the directory-based MESI protocol between
 the private level one caches owned by each core and the level two cache
 that shared among cores.
\end_layout

\begin_layout Standard
Besides the data, tag, and state, a cache block has a corresponding directory
 entry that contains the owner and sharers information of the block.
 The geometry parameters of each cache in the memory hierarchy are configured
 via XML files.
 The cache subblock granularity is currently not supported but planned for
 future work.
 The LRU cache replacement policy is implemented for the moment, the implementat
ions of more advanced policies are left as future work.
\end_layout

\begin_layout Subsubsection
On-Chip Interconnect
\end_layout

\begin_layout Standard
Currently, constant-latency on-chip interconnect is modeled, the cycle-accurate
 simulation of on-chip interconnect is left as future work.
\end_layout

\begin_layout Subsubsection
Interface to External DRAM Simulators
\end_layout

\begin_layout Standard
Currently, constant-latency DRAM access is modeled, the cycle-accurate simulatio
n of on-chip interconnect is left as future work.
 The integration of DRAMSim with Flexim is planned.
\end_layout

\begin_layout Section
Supporting Infrastructure
\end_layout

\begin_layout Standard
There are various supporting modules aside the aforementioned main components
 to maintain the Flexim's reusability.
 
\end_layout

\begin_layout Subsection
Eventing and Callback Mechanisms
\end_layout

\begin_layout Standard
In flexim, cycle-accurate simulation is driven by event signals per cycle.
 Generally speaking, an event can be any piece of code that is scheduled
 to execute at the specified time.
 This piece of code can be represented as a delegate in the D language.
 The delegate-based event queue (
\family typewriter
DelegateEventQueue
\family default
) is illustrated as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

class DelegateEventQueue: EventProcessor {
\end_layout

\begin_layout Plain Layout

  this() {
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

  void processEvents() {
\end_layout

\begin_layout Plain Layout

    if(currentCycle in this.events) {
\end_layout

\begin_layout Plain Layout

      foreach(event; this.events[currentCycle]) {
\end_layout

\begin_layout Plain Layout

        event();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      this.events.remove(currentCycle);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  void schedule(void delegate() event, ulong delay = 0) {
\end_layout

\begin_layout Plain Layout

    this.events[currentCycle + delay] ~= event;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  void delegate()[][ulong] events;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The delegate-based callback mechanism is used extensively in the implementation
 of the MESI cache coherence protocol.
 This way, the code is clean and readable.
\end_layout

\begin_layout Subsection
Categorized Logging Mechanism
\end_layout

\begin_layout Standard
The logging component supports configurable logging functionalities that
 can facilitate development and even be useful after release.
 The code skeleton of the Logger class is shown as below:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

class Logger {
\end_layout

\begin_layout Plain Layout

  static this() {
\end_layout

\begin_layout Plain Layout

    singleInstance = new Logger();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  bool enabled(LogCategory category) {
\end_layout

\begin_layout Plain Layout

    return category in this.logSwitches && this.logSwitches[category];
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  string message(string caption, string text) {
\end_layout

\begin_layout Plain Layout

    return format("[%d] 
\backslash
t%s%s", currentCycle, 
\end_layout

\begin_layout Plain Layout

      caption.endsWith("info") ? "" : "[" ~ caption ~ "] ", text);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  void infof(LogCategory, T...)(LogCategory category, T args) {
\end_layout

\begin_layout Plain Layout

    debug {
\end_layout

\begin_layout Plain Layout

      this.info(category, format(args));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  void info(LogCategory category, string text) {
\end_layout

\begin_layout Plain Layout

    debug {
\end_layout

\begin_layout Plain Layout

      if(this.enabled(category)) {
\end_layout

\begin_layout Plain Layout

        stdout.writeln(this.message(category ~ "|" ~ "info", text));
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  bool[LogCategory] logSwitches;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  static Logger singleInstance;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
XML-Based Input/Output for Configurations and Statistics
\end_layout

\begin_layout Standard
Extensible Markup Language (XML) is a standard and pervasive mechanism for
 representing structural data in a machine-readable and human-friendly way.
 Here XML-based configuration specification and statistics output are provided.
 For example, the following code shows how to serialize and deserialize
 a cache configuration using the provided XML I/O support:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

class CacheConfigXMLSerializer: XMLSerializer!(CacheConfig) { 
\end_layout

\begin_layout Plain Layout

  override XMLConfig save(CacheConfig cacheConfig) {
\end_layout

\begin_layout Plain Layout

    XMLConfig xmlConfig = new XMLConfig("CacheConfig");
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    xmlConfig["name"] = cacheConfig.name;
\end_layout

\begin_layout Plain Layout

    xmlConfig["level"] = to!(string)(cacheConfig.level);
\end_layout

\begin_layout Plain Layout

    xmlConfig["numSets"] = to!(string)(cacheConfig.numSets);
\end_layout

\begin_layout Plain Layout

    xmlConfig["assoc"] = to!(string)(cacheConfig.assoc);
\end_layout

\begin_layout Plain Layout

    xmlConfig["blockSize"] = to!(string)(cacheConfig.blockSize);
\end_layout

\begin_layout Plain Layout

    xmlConfig["hitLatency"] = to!(string)(cacheConfig.hitLatency);
\end_layout

\begin_layout Plain Layout

    xmlConfig["missLatency"] = to!(string)(cacheConfig.missLatency);
\end_layout

\begin_layout Plain Layout

    xmlConfig["policy"] = to!(string)(cacheConfig.policy);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    return xmlConfig;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  override CacheConfig load(XMLConfig xmlConfig) {
\end_layout

\begin_layout Plain Layout

    string name = xmlConfig["name"];
\end_layout

\begin_layout Plain Layout

    uint level = to!(uint)(xmlConfig["level"]);
\end_layout

\begin_layout Plain Layout

    uint numSets = to!(uint)(xmlConfig["numSets"]);
\end_layout

\begin_layout Plain Layout

    uint assoc = to!(uint)(xmlConfig["assoc"]);
\end_layout

\begin_layout Plain Layout

    uint blockSize = to!(uint)(xmlConfig["blockSize"]);
\end_layout

\begin_layout Plain Layout

    uint hitLatency = to!(uint)(xmlConfig["hitLatency"]);
\end_layout

\begin_layout Plain Layout

    uint missLatency = to!(uint)(xmlConfig["missLatency"]);
\end_layout

\begin_layout Plain Layout

    CacheReplacementPolicy policy = cast(CacheReplacementPolicy) (
\end_layout

\begin_layout Plain Layout

      xmlConfig["policy"]);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    CacheConfig cacheConfig = new CacheConfig(
\end_layout

\begin_layout Plain Layout

      name, level, numSets, assoc, blockSize, hitLatency, missLatency, policy);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    return cacheConfig;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  static this() {
\end_layout

\begin_layout Plain Layout

    singleInstance = new CacheConfigXMLSerializer();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  static CacheConfigXMLSerializer singleInstance;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Plotting and Table Generation for Experiments
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Section
Evaluation, Limitations and Future Work
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Subsection
Benchmark Evaluation
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Subsubsection
Criteria
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Subsubsection
Results
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Subsection
Comparison to Other Simulators
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Subsubsection
Results
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Subsection
Limitations and Future Work
\end_layout

\begin_layout Standard
Here are some of the limitations of Flexim.
 This list is not intended to be comprehensive, but rather aims to provide
 the user with an initial understanding of the capabilities of the Flexim
 simulation environment.
 These capabilities are subject to change in future releases.
\end_layout

\begin_layout Itemize
Only statically compiled MIPS32 binaries are supported by Flexim.
 Multi-ISA support and loading support of dynamically compiled programs
 are remained as future work.
\end_layout

\begin_layout Itemize
The explicit modeling of Miss Status Holding Registers (MSHRs) is not implemente
d and left as future work.
\end_layout

\begin_layout Itemize
Cycle-accurate on-chip interconnect and dram controller modeling is not
 implemented and left as future work.
\end_layout

\end_body
\end_document
