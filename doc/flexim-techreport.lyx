#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass paper
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing onehalf
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Flexim: A Decoupled Approach to Cycle-Accurate Simulation of Multicore Processor
s
\end_layout

\begin_layout Author
Min Cai
\end_layout

\begin_layout Abstract
Good cycle-accurate simulators are critical for conducting successful multicore
 processor architecture research nowadays.
 However, most of the existing simulators are written in C or C++ for speed
 considerations and the modeled computer structures and functionalities
 are too complicated to be implemented in a clear yet efficient way.
 The resulting unreadable code makes the simulator hard to use and extend.
 As a niche market, other not-so-realistic simulators are mostly used for
 educational and visualization purposes that they are written in traditional
 object-oriented languages such as Java or C#, which omit many machine details
 that are necessary for architectural study.
 There is a permanent need of balancing speed and elegance while simulating
 multicore architectures.
 
\end_layout

\begin_layout Abstract
In this report, we present Flexim, which exploits the idea of separation
 of structural and behavioral modeling of architectural components, and
 apply interface-based hierarchical modularity and cycle-accurate callback-based
 eventing to structural modeling and behavioral modeling, respectively.
 Flexim remodels the core functionalities of the classic SimpleScalar simulator
 and extends it to enable extensible timing simulation of out-of-order cores
 and multi-level cache hierarchies of multicore processors.
 Simulation results of a few popular benchmarks are shown for illustrative
 purposes.
\end_layout

\begin_layout Keywords
Cycle-accurate simulator, multicore processor architecture
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Decades of technology advances and architectural innovation in microprocessors
 has led to complex multicore designs that combine multiple physical processing
 cores on a single chip.
 Such design consists of three major parts: the microprocessor core, the
 cache hierarchy and the interconnection network.
 The design and implementation of the microprocessor core and the cache
 hierarchy are highly coupled and interrelated.
 And the interconnection network provides a fast and efficient transmission
 media that glues together all the computing and storage resources on the
 chip.
\end_layout

\begin_layout Standard
In order to evaluate the impact on the overall performance of any design
 improvement on any of the three major parts, many cycle-accurate simulators
 are created to model the three major parts and their integration in a system
 working as a whole.
 Yet many of architectural simulators come and go with a short lifecycle,
 because they are unable to satisfy the stringent yet fluid needs of innovating
 new computer architectures.
\end_layout

\begin_layout Standard
Most of the existing simulators are written in C or C++ for speed considerations
 and the modeled computer structures and functionalities are too complicated
 to be implemented in a clear yet efficient way.
 The resulting unreadable code makes the simulator hard to use and extend.
 As a niche market, other not-so-realistic simulators are mostly used for
 educational and visualization purposes that they are written in traditional
 object-oriented languages such as Java or C#, which omit many machine details
 that are necessary for architectural study.
 There is a permanent need of balancing speed and elegance while simulating
 multicore architectures.
 
\end_layout

\begin_layout Standard
In this work, we present Flexim, which exploits interface-based hierarchical
 modularity and cycle-accurate callback-based event-driven capabilities
 to remodel the core functionalities of the classic SimpleScalar simulator
 and extends it to enable detailed simulation of out-of-order cores and
 multi-level cache hierarchies of multicore processors.
 Table 1 
\color red
[]
\color inherit
 summarizes the main parameterizable options of Flexim, broken down according
 to the presented components classification.
\end_layout

\begin_layout Standard
The main contribution of this report is highlighted as below:
\end_layout

\begin_layout Enumerate
To our knowledge, the proposed Flexim simulator is the first object-oriented
 architectural simulator written in the modern systems programming language
 D in the world.
 Having good software engineering practice in mind, a few D language features
 are utilized extensively to improve the simulator's code readability, maintaina
bility and run-time reconfigurability.
\end_layout

\begin_layout Enumerate
The idea of separation of structural and behavioral modeling of architectural
 components is adopted extensively during the construction of the Flexim
 simulator to make creating reliable simulator modules much easier than
 before.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Interface-based hierarchical modularity is used for enabling the construction
 of replaceable and composable implementations to greatly ease the users'
 burden during the design and implementation process of new architectural
 improvements.
 
\end_layout

\begin_layout Enumerate
Cycle-accurate callback-based eventing is used for modeling the behavioral
 facet of simulation to clarify the interaction between the execution-driven
 simulator and the timing simulation modules.
\end_layout

\end_deeper
\begin_layout Standard
The rest of this technical report is structured as follows.
 Section 2 provides an overview of existing processor simulators and their
 comparative features.
 Section 3 describes Flexim with significant development details.
 Section 4 discusses the provisioning of modular and event-driven simulation
 of out-of-order cores and cache hierarchies.
 Simulation results from some popular benchmark suites are shown in section
 5.
 Finally, section 6 concludes the report.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
Multiple simulation environments, aimed for computer architecture research,
 have been developed.
 The most widely used simulator during the recent years has been SimpleScalar
 
\begin_inset CommandInset citation
LatexCommand cite
key "Austin2002"

\end_inset

, which serves as the basis of some Flexim functional simulation modules.
 It models an out-of-order superscalar processor.
 Lots of extensions have been applied to SimpleScalar to model certain aspects
 of superscalar processors in a more accurate manner.
 For example, the HotLeakage simulator [] quantifies leakage energy consumption.
 However, SimpleScalar is quite difficult to extend to model new parallel
 microarchitectures without significantly changing its structure.
 In spite of this fact, three SimpleScalar extensions to support multithreading
 and/or multicore have been implemented in the SSMT [], M-Sim [] and Multi2Sim
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ubal2007multi2sim"

\end_inset

 simulators.
 While SSMT and M-Sim are useful to implement designs based on simultaneous
 multithreaded processors, Multi2sim provides detailed simulation of multicore
 multithreaded processors in x86 ISA.
\end_layout

\begin_layout Standard
SimpleScalar is an 
\shape italic
application-only
\shape default
 tool, that is, a simulator that executes directly an application and simulate
 its execution by providing a simplistic and fictitious underlying operation
 system via system call emulation.
 Such tools are characterized by not supporting the architecture-specific
 privileged instruction set, since applications are not allowed to execute
 it.
 However, application-only simulators have the advantage of isolating the
 application execution, so statistics are not affected by the simulation
 of a real operating system.
 The proposed simulator Flexim can be classified as an application-only
 simulator, too.
\end_layout

\begin_layout Standard
In contrast to the application-only simulators, a set of so-called 
\shape italic
full-system
\shape default
 simulators are available.
 In such environments, an unmodified operating system is booted over the
 simulator and applications run at the same time over the simulated operating
 system.
 Thus, the entire instruction set and the interfacing with functional models
 of many I/O devices need be implemented, but no emulation of system calls
 is required.
 Although this model provides higher simulation power, it involves a huge
 computational overhead and sometimes unnecessary simulation accuracy.
\end_layout

\begin_layout Standard
Simics 
\begin_inset CommandInset citation
LatexCommand cite
key "Magnusson2002"

\end_inset

 is an example of full-system functional simulator which is commonly used
 for multi-processor systems simulation although it is not freely available.
 Simics provides a powerful set of APIs that a variety of its extensions
 have been created for specific purposes in this research area.
 GEMS 
\begin_inset CommandInset citation
LatexCommand cite
key "Martin2005"

\end_inset

 is a popular Simics extension which provides timing simulation capabilities
 to model the architectural details of multiprocessors such as instruction
 fetch and decode, branch prediction, dynamic instruction scheduling and
 execution and speculative memory hierarchy access.
 GEMS also provides a specification language for defining cache coherence
 protocols.
 However, any simulator based on Simics, like GEMS, must boot and run an
 operating system, so high computational load is increased with each extension.
\end_layout

\begin_layout Standard
GEMS provides an important feature of processor simulators which is called
 
\shape italic
timing first simulation
\shape default
.
 In this scheme, for example, one timing simulation module traces the state
 of the processor pipeline while instructions traverse it, and another timing
 simulation module traces the state of the caches while requests traverses
 them.
 In the pipeline case, the functional module is only called to actually
 execute the instructions when they reach the commit stage, so the correct
 execution paths are always guaranteed by a previously developed robust
 simulator.
 The timing-first approach confers efficiency, robustness, and the possibility
 of creating a series of simulators gradually with more and more details
 and accuracy.
\end_layout

\begin_layout Standard
And the last well-known simulator that we mention here is M5 
\begin_inset CommandInset citation
LatexCommand cite
key "Binkert2006"

\end_inset

 .
 This simulator provides support for simple one-CPU functional CPU, out-of-order
 SMT-capable CPUs, multiprocessors and coherence caches.
 It integrates the full-system and application-only simulation modes.
\end_layout

\begin_layout Standard
As summary, Flexim has been developed integrating the most significant character
istics of important simulators, such as separation of functional and timing
 simulation, SMT and multiprocessor support and directory-based cache coherence.
 Table 2 gathers Flexim's main features and marks the differences from existing
 simulators.
 Additional features of Flexim are detailed in further sections.
\end_layout

\begin_layout Section
Basic Simulator Description
\end_layout

\begin_layout Standard
This section details the main implementation issues that lead to a final
 simulation environment, and exposes some tips to bring it into use with
 workloads that created from the combination of some popular benchmarks.
 These aspects are addressed by showing some usage scenarios, describing
 briefly the process of loading an ELF MIPS32 executable into a running
 process's virtual memory, and analyzing the simulator structure that divided
 by functional and detailed simulation.
\end_layout

\begin_layout Subsection
Simulator and Workloads Compilation
\end_layout

\begin_layout Standard
Flexim is written in the systems programming language D, so in order to
 compile Flexim code, you need to obtain the latest DMD 2.0 compiler from
 DigitalMars' website
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://www.digitalmars.com/d/download.html"

\end_inset

.
\end_layout

\end_inset

, and follows the provided instructions to install the compiler.
 The latest Flexim code can be downloaded at the project's website on Github
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://github.com/mcai/flexim/"

\end_inset

.
\end_layout

\end_inset

, as a compressed tar file, and has been tested on x86 and x64 machine architect
ures, with Linux OS.
 The following commands should be entered in a command terminal to compile
 it:
\end_layout

\begin_layout Standard

\family typewriter
tar xzf mcai-flexim-<checkout_version>.tar.gz
\end_layout

\begin_layout Standard

\family typewriter
cd mcai-flexim-<checkout_version>
\end_layout

\begin_layout Standard

\family typewriter
make
\end_layout

\begin_layout Standard
Flexim simulates final executable files, statically compiled for the MIPS32
 Little Endian architecture, so a cross-compiler is also required to compile
 your own program sources.
 There is a workable MIPS32 cross-compiler (cross-compiler-mipsel.tar.bz2)
 available on the Flexim's project website on Github
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://github.com/mcai/flexim/downloads/"

\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Dynamic linking is not supported, so executables must be compiled statically.
 A command line to compile a program composed by a single source file named
 program.c could be:
\end_layout

\begin_layout Standard

\family typewriter
mipsel-linux-gcc program.c -Wall -o program.mipsel32 -static
\end_layout

\begin_layout Standard
Executables usually have an approximate minimum size of 4MB, since all libraries
 are linked with it.
 For programs that use the math library or 
\family typewriter
pthread
\family default
 library, simply include 
\family typewriter
-lm
\family default
 or 
\family typewriter
-lpthread
\family default
 into the command line.
 Sample Makefiles for a few benchmarks are provided within the Flexim distributi
on.
\end_layout

\begin_layout Subsection
Executable File Loader
\end_layout

\begin_layout Standard
In a simulation environment, program loading is the process in which an
 executable file is mapped into different virtual memory regions of a new
 software context, and its register file and stack are initialized to start
 execution.
 In a real machine, the operating system is in charge of these housework.
 However, Flexim, as other widely used application-only simulators (e.g.,
 SimpleScalar), is not aimed at supporting the simulation of an OS, but
 only the execution of target applications.
 For this reason, program loading must be managed by the simulator during
 the initialization.
\end_layout

\begin_layout Standard
The executable files output by 
\family typewriter
gcc
\family default
 follow the ELF (Executable and Linkable Format) specification.
 This format is aimed for shared libraries, core dumps and object code,
 including executable files.
 An ELF file is made up of an ELF header, a set of arguments and a set of
 sections.
 Typically, one or more sections are enclosed in a segment.
 ELF sections are identified by a name and contain useful data for program
 loading or debugging.
 They are labeled with a set of flags that indicate its type and the way
 they have to be handled during the program loading.
\end_layout

\begin_layout Standard
Flexim embodies the needed classes and methods to list the executable file
 sections and access their contents.
 The loader module sweeps all of them and extracts their main attributes:
 starting address, size, flags and content.
 When the flags of a section indicate that it is 
\family typewriter
loadable
\family default
, its contents are copied into memory after the corresponding fixed starting
 address.
\end_layout

\begin_layout Standard
The next step of the program loading process is to initialize the process
 stack.
 The stack is a memory region with a dynamically variable length, starting
 at the virtual address 
\family typewriter
0xc0000000
\family default
 and growing toward lower memory addresses.
 The aim of the program stack is to store function local variables and parameter
s.
 During the program execution, the stack pointer (register $sp) is managed
 by the own program code.
 In contrast, when the program starts, it expects some data in it.
 This fact can be observed by looking at the standard header of the main
 function in a C program:
\end_layout

\begin_layout Standard

\family typewriter
int main(int argc, char **argv, char **envp);
\end_layout

\begin_layout Standard
When the main function starts, three parameters are expected starting at
 the memory location specified by the stack pointer.
 At address [$sp], an integer value represents the number of arguments passed
 through the command line.
 At [$sp+4], an integer value indicates the memory address corresponding
 to a sequence of argc pointers, which at the same time represent each a
 null-terminated sequence of characters (program arguments).
\end_layout

\begin_layout Standard
Finally, at address [$sp +8], another memory address points to an array
 of strings (i.e., pointers to char sequences).
 These strings represent the environment variables, accessible through envp[0],
 envp[1]...
 inside the C program, or by calls to getenv functions.
 Notice that there is no integer value indicating the number of defined
 environment variables, so the end of the envp array is denoted with a final
 null pointer.
\end_layout

\begin_layout Standard
Taking this stack configuration into account, the program loader must write
 program arguments, environment variables and
\family typewriter
 main
\family default
 function arguments into the simulated memory.
\end_layout

\begin_layout Standard
The last step is the initialization of the register file.
 This includes the [$sp] register, which has been progressively updated
 during the stack initialization, and the PC and NPC registers.
 The initial value of the register PC is specified in the ELF header of
 the executable file as the program entry point.
 Register NPC is not explicitly defined in the MIPS32 architecture, but
 it is used internally by the simulator to ease the branch delay slot management.
\end_layout

\begin_layout Subsection
Functional Simulation
\end_layout

\begin_layout Standard
The functional simulation engine provides an interface to the rest of the
 simulator and implements functionalities such as creating or destroying
 software contexts, performing program loading, enumerating existing contexts,
 consulting their status, executing a new instruction.
\end_layout

\begin_layout Standard
The supported machine architecture is MIPS32 Little Endian.
 The main reasons for choosing the MIPS32 instruction set 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The MIPS32 instructions that are not used by the 
\family typewriter
gcc
\family default
 compiler are excluded from this implementation.
 Also instructions belonging to the privileged instruction set are not implement
ed.
\end_layout

\end_inset

 is the availability of an easy-to-understand architecture specification
 and the simple and systematic identification of machine instructions, motivated
 by a fixed instruction size and an instruction decomposition in instruction
 fields.
\end_layout

\begin_layout Standard
As a remark, the difference between the terms 
\family typewriter
context
\family default
 and 
\family typewriter
thread
\family default
 should be clarified.
 A 
\family typewriter
context
\family default
 is used in this work as a software entity, defined by the status of a virtual
 memory image and a logical file.
 In contrast, a 
\family typewriter
thread
\family default
 is used as a processor hardware entity, and can comprise a physical register
 file, a set of physical memory pages, a set of entries in the pipeline
 queues, etc.
 The simulator kernel only handles contexts, and does not know of architecture
 specific hardware, such as threads or cores.
 
\color red
[work should be done here]
\end_layout

\begin_layout Standard
Since Flexim simulates target applications, the underlying operating system
 services (such as program loading or system calls) are performed internally
 by the simulator.
 This is done by modifying the memory and logical registers status so that
 the application sees the result of the system call.
\end_layout

\begin_layout Subsection
Detailed Simulation
\end_layout

\begin_layout Standard
The Flexim detailed simulator uses the functional engine to perform an execution
-driven simulation: during each cycle, a sequence of calls update the existing
 contexts states.
 The detailed simulator analyzes the nature of the recently executed machine
 instructions and accounts the operation latencies incurred by hardware
 structures.
\end_layout

\begin_layout Standard
The branch predictor implementation is based on Marss86.
 Caches and TLBs are implemented, including the MESI cache coherence protocol.
 Current interconnection network is a constant-latency simplification.
 MMU (Memory Management Unit) is provided to map virtual address spaces
 of contexts into a single physical memory space.
 Physical addresses are then used to index caches or branch predictors,
 without including the context identifier across modules.
\end_layout

\begin_layout Standard
The out-of-order pipeline modeling module defines and manages a few processor
 structures such as decode buffers, reorder buffers, load store queues and
 functional units.
 And the pipeline stages defines the behavior of the configured multithreaded
 multicore processor.
\end_layout

\begin_layout Standard
Configuration specification and statistics output for the simulated entities
 such as cores, threads and caches are implemented via XML-formatted I/O,
 which is easy to use and machine-readable.
\end_layout

\begin_layout Section
Decoupled and Event-Driven Cycle-Accurate Simulation
\end_layout

\begin_layout Subsection
Concept 1: Interface-Based Separation of Structural and Behavioral Modeling
\end_layout

\begin_layout Standard
The modeling of computer architecture can be classified into two types of
 modelings: structural modeling and behavioral modeling.
 Structural modeling refers to the modeling of static structural elements
 such as the internal structure of caches, whereas behavioral modeling refers
 to the modeling of dynamic behavioral elements such as the cache replacement
 policies and cache coherence protocols.
 
\end_layout

\begin_layout Standard
The complexity of multicore components and their interactions make it very
 hard to model the structural and behavioral aspects of modeling separately.
 Existing simulators written in traditional C or C++ programming languages
 inevitably makes the structural modeling elements are scattered among behaviora
l modeling elements.
 In other words, the structural modeling elements are entangled which means
 that its code is intermixed with code that implements behavioral modeling
 elements.
\end_layout

\begin_layout Standard
In order to solve the aforementioned problem of scattering and tangling
 of structural and behavioral aspects of architectural modeling, we use
 interface-based design methodology to abstract the implementation of structural
 elements, and use interfaces in place of concrete implementations of structural
 elements in the implementation of behavioral elements.
\end_layout

\begin_layout Subsection
Concept 2: Cycle-Accurate Callback-Based Eventing
\end_layout

\begin_layout Standard
As explained above, most Flexim modules implement an execution-driven simulation
, as SimpleScalar does.
 In such a model, function calls that activate some processor component
 (e.g., a cache or predictor) have an interface that receives a set of parameters
 and returns the latency needed to complete the access.
 Nevertheless, there are some situations where this latency is not a determinist
ic value and cannot be obtained in the instant when the function call is
 performed.
 Instead, it must be simulated cycle by cycle.
\end_layout

\begin_layout Standard
This is the case of interconnects and caches.
 In a generic topology, the delay of a message transference cannot be determined
 when the message is injected, because it depends on the dynamic network
 state.
 In addition, this state depends on future message transferences, so it
 cannot be computed unless advancing the simulation.
\end_layout

\begin_layout Standard
Because a cache access in a multithread-multicore environment may cause
 coherence messages transmitted across interconnection networks, the cache
 access latency cannot be estimated prior to the network access.
 In addition, the cache access latency can be affected by the internal state
 of accessed cache blocks, which is dynamically changed by cache writes
 and invalidates.
 Thus, the cache module is also implemented with an event-driven model.
 When the execution-driven simulator performs a cache access, it passes
 the handle of a callback method that specifies the action to be performed
 when the cache system completes the servicing of the cache access request.
\end_layout

\begin_layout Subsection
Simulating Out-of-Order Cores
\end_layout

\begin_layout Subsubsection
Structural Modeling
\end_layout

\begin_layout Paragraph
Physical Register File.
\end_layout

\begin_layout Subparagraph
Physical Register.
\end_layout

\begin_layout Paragraph
Functional Unit Pool.
\end_layout

\begin_layout Subparagraph
Functional Unit.
\end_layout

\begin_layout Paragraph
Branch Predictors.
\end_layout

\begin_layout Paragraph
Decode Buffer.
\end_layout

\begin_layout Subparagraph
Decode Buffer Entry.
\end_layout

\begin_layout Paragraph
Reorder Buffers.
\end_layout

\begin_layout Subparagraph
Reorder Buffer Entry.
\end_layout

\begin_layout Paragraph
Load Store Queues.
\end_layout

\begin_layout Subsubsection
Behavioral Modeling
\end_layout

\begin_layout Paragraph
Physical Register Allocation and Deallocation.
\end_layout

\begin_layout Paragraph
Functional Unit Acquisition and Release.
\end_layout

\begin_layout Paragraph
The Five Pipeline Stages.
\end_layout

\begin_layout Enumerate
Fetch
\end_layout

\begin_layout Enumerate
Decode & Rename
\end_layout

\begin_layout Enumerate
Dispatch
\end_layout

\begin_layout Enumerate
Issue
\end_layout

\begin_layout Enumerate
Commit
\end_layout

\begin_layout Subsection
Simulating Multi-Level Cache Hierarchies
\end_layout

\begin_layout Subsubsection
Structural Modeling
\end_layout

\begin_layout Paragraph
Directory.
\end_layout

\begin_layout Subparagraph
Directory Entry.
\end_layout

\begin_layout Paragraph
Cache.
\end_layout

\begin_layout Subparagraph
Cache Block.
\end_layout

\begin_layout Subparagraph
Cache Set.
\end_layout

\begin_layout Subsubsection
Behavioral Modeling
\end_layout

\begin_layout Paragraph
Cache Replacement (LRU as an Example).
\end_layout

\begin_layout Paragraph
Cache Coherence (Directory Based MESI as an Example).
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Itemize
Further works
\end_layout

\begin_deeper
\begin_layout Itemize
Functional simulation: parallel workload support
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/home/itecgo/research/refs_classfied/default"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
