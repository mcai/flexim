#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass paper
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing onehalf
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Flexim: Facilitating User-Friendly Cycle-Accurate Simulation of Multicore
 Processors
\end_layout

\begin_layout Author
Min Cai, Zhimin Gu
\end_layout

\begin_layout Institution
Beijing Institute of Technology, Beijing 100081, P.R.China
\end_layout

\begin_layout Abstract
Good cycle-accurate simulators are critical for conducting successful multicore
 processor architecture research nowadays.
 However, most of the existing simulators are written in C or C++ for speed
 considerations and the modeled computer structures and functionalities
 are too complicated to be implemented in a clear yet efficient way.
 The resulting unreadable code makes the simulator hard to use and extend.
 As a niche market, other not-so-realistic simulators are mostly used for
 educational and visualization purposes that they are written in traditional
 object-oriented languages such as Java or C#, which omit many machine details
 that are necessary for architectural study.
 There is a permanent need of balancing speed and elegance while simulating
 multicore architectures.
 
\end_layout

\begin_layout Abstract
In this paper, we present Flexim, a user-friendly cycle-accurate multicore
 archiectural simulator, which consists of the simulator core and the GUI
 based Integrated Simulation Environment (ISE) .
 Within the core, Flexim remodels the core functionalities of the classic
 SimpleScalar simulator and extends it to enable configurable timing simulation
 of out-of-order cores and multi-level cache hierarchies of multicore processors.
 It exploits interface-based hierarchical modularity and cycle-accurate
 callback-based eventing to improve the modualrity and extensibility of
 the simulator core.
 For the GUI-based ISE, Flexim uses XML files and setup wizards to ease
 the configuration of the simulator, and utilizes graph visualization to
 provide static and dynamic views of the multicore archietecture under simulatio
n.
 Simulation results from a few popular benchmark suites such as Olden and
 CPU2006 are shown for illustrative purposes.
\end_layout

\begin_layout Keywords
Cycle-accurate simulator, multicore processor architecture
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Decades of technology advances and architectural innovation in microprocessors
 has led to complex multicore designs that combine multiple physical processing
 cores on a single chip.
 Such design consists of three major parts: the microprocessor core, the
 cache hierarchy and the interconnection network.
 The design and implementation of the microprocessor core and the cache
 hierarchy are highly coupled and interrelated.
 And the interconnection network provides a fast and efficient transmission
 media that glues together all the computing and storage resources on the
 chip.
\end_layout

\begin_layout Standard
In order to evaluate the impact on the overall performance of any design
 improvement on any of the three major parts, many cycle-accurate simulators
 are created to model the three major parts and their integration in a system
 working as a whole.
 Yet many of architectural simulators come and go with a short lifecycle,
 because they are unable to satisfy the stringent yet fluid needs of innovating
 new computer architectures.
\end_layout

\begin_layout Standard
Most of the existing simulators are written in C or C++ for speed considerations
 and the modeled computer structures and functionalities are too complicated
 to be implemented in a clear yet efficient way.
 The resulting unreadable code makes the simulator hard to use and extend.
 As a niche market, other not-so-realistic simulators are mostly used for
 educational and visualization purposes that they are written in traditional
 object-oriented languages such as Java or C#, which omit many machine details
 that are necessary for architectural study.
 There is a permanent need of balancing speed and elegance while simulating
 multicore architectures.
 
\end_layout

\begin_layout Standard
In this work, we present Flexim, which exploits interface-based hierarchical
 modularity and cycle-accurate callback-based event-driven capabilities
 to remodel the core functionalities of the classic SimpleScalar simulator
 and extends it to enable detailed simulation of out-of-order cores and
 multi-level cache hierarchies of multicore processors.
 Table 1 
\color red
[]
\color inherit
 summarizes the main parameterizable options of Flexim, broken down according
 to the presented components classification.
\end_layout

\begin_layout Standard
The main contribution of this report is highlighted as below:
\end_layout

\begin_layout Enumerate
To our knowledge, the proposed Flexim simulator is the first object-oriented
 architectural simulator written in the modern systems programming language
 D in the world.
 Having good software engineering practice in mind, a few D language features
 are utilized extensively to improve the simulator's code readability, maintaina
bility and run-time reconfigurability.
\end_layout

\begin_layout Enumerate
The idea of separation of structural and behavioral modeling of architectural
 components is adopted extensively during the construction of the Flexim
 simulator to make creating reliable simulator modules much easier than
 before.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Interface-based hierarchical modularity is used for enabling the construction
 of replaceable and composable implementations to greatly ease the users'
 burden during the design and implementation process of new architectural
 improvements.
 
\end_layout

\begin_layout Enumerate
Cycle-accurate callback-based eventing is used for modeling the behavioral
 facet of simulation to clarify the interaction between the execution-driven
 simulator and the timing simulation modules.
\end_layout

\begin_layout Enumerate
A common infrastructure that supports logging, eventing and XML-based IO
 for configuration specification and statitistcs output that fits the needs
 required by the simulation process as illustrated in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simulation-Workflow"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename simulation_workflow.pdf
	scale 38
	BoundingBox 200bp 100bp 500bp 600bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Simulation Workflow
\begin_inset CommandInset label
LatexCommand label
name "fig:Simulation-Workflow"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The rest of this technical report is structured as follows.
 Section 2 provides an overview of existing processor simulators and their
 comparative features.
 Section 3 describes Flexim with significant development details.
 Section 4 discusses the provisioning of modular and event-driven simulation
 of out-of-order cores and cache hierarchies.
 Simulation results from some popular benchmark suites are shown in section
 5.
 Finally, section 6 concludes the report.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
Multiple simulation environments, aimed for computer architecture research,
 have been developed.
 The most widely used simulator during the recent years has been SimpleScalar
 
\begin_inset CommandInset citation
LatexCommand cite
key "Austin2002"

\end_inset

, which serves as the basis of some Flexim functional simulation modules.
 It models an out-of-order superscalar processor.
 Lots of extensions have been applied to SimpleScalar to model certain aspects
 of superscalar processors in a more accurate manner.
 For example, the HotLeakage simulator [] quantifies leakage energy consumption.
 However, SimpleScalar is quite difficult to extend to model new parallel
 microarchitectures without significantly changing its structure.
 In spite of this fact, three SimpleScalar extensions to support multithreading
 and/or multicore have been implemented in the SSMT [], M-Sim [] and Multi2Sim
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ubal2007multi2sim"

\end_inset

 simulators.
 While SSMT and M-Sim are useful to implement designs based on simultaneous
 multithreaded processors, Multi2sim provides detailed simulation of multicore
 multithreaded processors in x86 ISA.
\end_layout

\begin_layout Standard
SimpleScalar is an 
\shape italic
application-only
\shape default
 tool, that is, a simulator that executes directly an application and simulate
 its execution by providing a simplistic and fictitious underlying operation
 system via system call emulation.
 Such tools are characterized by not supporting the architecture-specific
 privileged instruction set, since applications are not allowed to execute
 it.
 However, application-only simulators have the advantage of isolating the
 application execution, so statistics are not affected by the simulation
 of a real operating system.
 The proposed simulator Flexim can be classified as an application-only
 simulator, too.
\end_layout

\begin_layout Standard
In contrast to the application-only simulators, a set of so-called 
\shape italic
full-system
\shape default
 simulators are available.
 In such environments, an unmodified operating system is booted over the
 simulator and applications run at the same time over the simulated operating
 system.
 Thus, the entire instruction set and the interfacing with functional models
 of many I/O devices need be implemented, but no emulation of system calls
 is required.
 Although this model provides higher simulation power, it involves a huge
 computational overhead and sometimes unnecessary simulation accuracy.
\end_layout

\begin_layout Standard
Simics 
\begin_inset CommandInset citation
LatexCommand cite
key "Magnusson2002"

\end_inset

 is an example of full-system functional simulator which is commonly used
 for multi-processor systems simulation although it is not freely available.
 Simics provides a powerful set of APIs that a variety of its extensions
 have been created for specific purposes in this research area.
 GEMS 
\begin_inset CommandInset citation
LatexCommand cite
key "Martin2005"

\end_inset

 is a popular Simics extension which provides timing simulation capabilities
 to model the architectural details of multiprocessors such as instruction
 fetch and decode, branch prediction, dynamic instruction scheduling and
 execution and speculative memory hierarchy access.
 GEMS also provides a specification language for defining cache coherence
 protocols.
 However, any simulator based on Simics, like GEMS, must boot and run an
 operating system, so high computational load is increased with each extension.
\end_layout

\begin_layout Standard
GEMS provides an important feature of processor simulators which is called
 
\shape italic
timing first simulation
\shape default
.
 In this scheme, for example, one timing simulation module traces the state
 of the processor pipeline while instructions traverse it, and another timing
 simulation module traces the state of the caches while requests traverses
 them.
 In the pipeline case, the functional module is only called to actually
 execute the instructions when they reach the commit stage, so the correct
 execution paths are always guaranteed by a previously developed robust
 simulator.
 The timing-first approach confers efficiency, robustness, and the possibility
 of creating a series of simulators gradually with more and more details
 and accuracy.
\end_layout

\begin_layout Standard
And the last well-known simulator that we mention here is M5 
\begin_inset CommandInset citation
LatexCommand cite
key "Binkert2006"

\end_inset

 .
 This simulator provides support for simple one-CPU functional CPU, out-of-order
 SMT-capable CPUs, multiprocessors and coherence caches.
 It integrates the full-system and application-only simulation modes.
\end_layout

\begin_layout Standard
As summary, Flexim has been developed integrating the most significant character
istics of important simulators, such as separation of functional and timing
 simulation, SMT and multiprocessor support and directory-based cache coherence.
 Table 2 gathers Flexim's main features and marks the differences from existing
 simulators.
 Additional features of Flexim are detailed in further sections.
\end_layout

\begin_layout Section
Basic Simulator Description
\end_layout

\begin_layout Standard
This section details the main implementation issues that lead to a final
 simulation environment, and exposes some tips to bring it into use with
 workloads that created from the combination of some popular benchmarks.
 These aspects are addressed by showing some usage scenarios, describing
 briefly the process of loading an ELF MIPS32 executable into a running
 process's virtual memory, and analyzing the simulator structure that divided
 by functional and detailed simulation.
\end_layout

\begin_layout Subsection
Simulator and Workloads Compilation
\end_layout

\begin_layout Standard
Flexim is written in the systems programming language D, so in order to
 compile Flexim code, you need to obtain the latest DMD 2.0 compiler from
 DigitalMars' website
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://www.digitalmars.com/d/download.html"

\end_inset

.
\end_layout

\end_inset

, and follows the provided instructions to install the compiler.
 The latest Flexim code can be downloaded at the project's website on Github
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://github.com/mcai/flexim/"

\end_inset

.
\end_layout

\end_inset

, as a compressed tar file, and has been tested on x86 and x64 machine architect
ures, with Linux OS.
 The following commands should be entered in a command terminal to compile
 it:
\end_layout

\begin_layout Standard

\family typewriter
tar xzf mcai-flexim-<checkout_version>.tar.gz
\end_layout

\begin_layout Standard

\family typewriter
cd mcai-flexim-<checkout_version>
\end_layout

\begin_layout Standard

\family typewriter
make
\end_layout

\begin_layout Standard
Flexim simulates final executable files, statically compiled for the MIPS32
 Little Endian architecture, so a cross-compiler is also required to compile
 your own program sources.
 There is a workable MIPS32 cross-compiler (cross-compiler-mipsel.tar.bz2)
 available on the Flexim's project website on Github
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://github.com/mcai/flexim/downloads/"

\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Dynamic linking is not supported, so executables must be compiled statically.
 A command line to compile a program composed by a single source file named
 program.c could be:
\end_layout

\begin_layout Standard

\family typewriter
mipsel-linux-gcc program.c -Wall -o program.mipsel32 -static
\end_layout

\begin_layout Standard
Executables usually have an approximate minimum size of 4MB, since all libraries
 are linked with it.
 For programs that use the math library or 
\family typewriter
pthread
\family default
 library, simply include 
\family typewriter
-lm
\family default
 or 
\family typewriter
-lpthread
\family default
 into the command line.
 Sample Makefiles for a few benchmarks are provided within the Flexim distributi
on.
\end_layout

\begin_layout Subsection
Executable File Loader
\end_layout

\begin_layout Standard
In a simulation environment, program loading is the process in which an
 executable file is mapped into different virtual memory regions of a new
 software context, and its register file and stack are initialized to start
 execution.
 In a real machine, the operating system is in charge of these housework.
 However, Flexim, as other widely used application-only simulators (e.g.,
 SimpleScalar), is not aimed at supporting the simulation of an OS, but
 only the execution of target applications.
 For this reason, program loading must be managed by the simulator during
 the initialization.
\end_layout

\begin_layout Standard
The executable files output by 
\family typewriter
gcc
\family default
 follow the ELF (Executable and Linkable Format) specification.
 This format is aimed for shared libraries, core dumps and object code,
 including executable files.
 An ELF file is made up of an ELF header, a set of arguments and a set of
 sections.
 Typically, one or more sections are enclosed in a segment.
 ELF sections are identified by a name and contain useful data for program
 loading or debugging.
 They are labeled with a set of flags that indicate its type and the way
 they have to be handled during the program loading.
\end_layout

\begin_layout Standard
Flexim embodies the needed classes and methods to list the executable file
 sections and access their contents.
 The loader module sweeps all of them and extracts their main attributes:
 starting address, size, flags and content.
 When the flags of a section indicate that it is 
\family typewriter
loadable
\family default
, its contents are copied into memory after the corresponding fixed starting
 address.
\end_layout

\begin_layout Standard
The next step of the program loading process is to initialize the process
 stack.
 The stack is a memory region with a dynamically variable length, starting
 at the virtual address 
\family typewriter
0xc0000000
\family default
 and growing toward lower memory addresses.
 The aim of the program stack is to store function local variables and parameter
s.
 During the program execution, the stack pointer (register $sp) is managed
 by the own program code.
 In contrast, when the program starts, it expects some data in it.
 This fact can be observed by looking at the standard header of the main
 function in a C program:
\end_layout

\begin_layout Standard

\family typewriter
int main(int argc, char **argv, char **envp);
\end_layout

\begin_layout Standard
When the main function starts, three parameters are expected starting at
 the memory location specified by the stack pointer.
 At address [$sp], an integer value represents the number of arguments passed
 through the command line.
 At [$sp+4], an integer value indicates the memory address corresponding
 to a sequence of argc pointers, which at the same time represent each a
 null-terminated sequence of characters (program arguments).
\end_layout

\begin_layout Standard
Finally, at address [$sp +8], another memory address points to an array
 of strings (i.e., pointers to char sequences).
 These strings represent the environment variables, accessible through envp[0],
 envp[1]...
 inside the C program, or by calls to getenv functions.
 Notice that there is no integer value indicating the number of defined
 environment variables, so the end of the envp array is denoted with a final
 null pointer.
\end_layout

\begin_layout Standard
Taking this stack configuration into account, the program loader must write
 program arguments, environment variables and
\family typewriter
 main
\family default
 function arguments into the simulated memory.
\end_layout

\begin_layout Standard
The last step is the initialization of the register file.
 This includes the [$sp] register, which has been progressively updated
 during the stack initialization, and the PC and NPC registers.
 The initial value of the register PC is specified in the ELF header of
 the executable file as the program entry point.
 Register NPC is not explicitly defined in the MIPS32 architecture, but
 it is used internally by the simulator to ease the branch delay slot management.
\end_layout

\begin_layout Subsection
Functional Simulation and Detailed Simulation
\end_layout

\begin_layout Standard
The relationship between Flexim modules used for functional simulation and
 detailed simulation are illustrated in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:functional_vs_timing_sinmulation"

\end_inset

.
 The simulated workload and the system call emulation module provides the
 input instruction stream to be executed by the functional simulation module.
 And the functional simulation module feeds the execution flow information
 to the timing simulation module, and the timing simulation module provides
 feedback containing the requested timing information of instructions and
 memory requests.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename simulated_component_interaction.pdf
	scale 63
	BoundingBox 75bp 210bp 725bp 450bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The relationship between workload, functional simulation and timing simulation.
\begin_inset CommandInset label
LatexCommand label
name "fig:functional_vs_timing_sinmulation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Functional Simulation
\end_layout

\begin_layout Standard
The functional simulation engine provides an interface to the rest of the
 simulator and implements functionalities such as creating or destroying
 software contexts, performing program loading, enumerating existing contexts,
 consulting their status, executing a new instruction.
\end_layout

\begin_layout Standard
The supported machine architecture is MIPS32 Little Endian.
 The main reasons for choosing the MIPS32 instruction set 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The MIPS32 instructions that are not used by the 
\family typewriter
gcc
\family default
 compiler are excluded from this implementation.
 Also instructions belonging to the privileged instruction set are not implement
ed.
\end_layout

\end_inset

 is the availability of an easy-to-understand architecture specification
 and the simple and systematic identification of machine instructions, motivated
 by a fixed instruction size and an instruction decomposition in instruction
 fields.
\end_layout

\begin_layout Standard
As a remark, the difference between the terms 
\family typewriter
context
\family default
 and 
\family typewriter
thread
\family default
 should be clarified.
 A 
\family typewriter
context
\family default
 is used in this work as a software entity, defined by the status of a virtual
 memory image and a logical file.
 In contrast, a 
\family typewriter
thread
\family default
 is used as a processor hardware entity, and can comprise a physical register
 file, a set of physical memory pages, a set of entries in the pipeline
 queues, etc.
 The simulator kernel only handles contexts, and does not know of architecture
 specific hardware, such as threads or cores.
 
\color red
[work should be done here]
\end_layout

\begin_layout Standard
Since Flexim simulates target applications, the underlying operating system
 services (such as program loading or system calls) are performed internally
 by the simulator.
 This is done by modifying the memory and logical registers status so that
 the application sees the result of the system call.
\end_layout

\begin_layout Subsubsection
Detailed Simulation
\end_layout

\begin_layout Standard
The Flexim detailed simulator uses the functional engine to perform an execution
-driven simulation: during each cycle, a sequence of calls update the existing
 contexts states.
 The detailed simulator analyzes the nature of the recently executed machine
 instructions and accounts the operation latencies incurred by hardware
 structures.
\end_layout

\begin_layout Standard
The branch predictor implementation is based on Marss86.
 Caches and TLBs are implemented, including the MESI cache coherence protocol.
 Current interconnection network is a constant-latency simplification.
 MMU (Memory Management Unit) is provided to map virtual address spaces
 of contexts into a single physical memory space.
 Physical addresses are then used to index caches or branch predictors,
 without including the context identifier across modules.
\end_layout

\begin_layout Standard
The out-of-order pipeline modeling module defines and manages a few processor
 structures such as decode buffers, reorder buffers, load/store queues and
 functional units.
 And the pipeline stages defines the behavior of the configured multithreaded
 multicore processor.
\end_layout

\begin_layout Standard
Configuration specification and statistics output for the simulated entities
 such as cores, threads and caches are implemented via XML-formatted I/O,
 which is easy to use and machine-readable.
\end_layout

\begin_layout Section
Decoupled and Event-Driven Cycle-Accurate Simulation of Multicore Architectures
\end_layout

\begin_layout Standard
As shown in Fig.
\begin_inset CommandInset label
LatexCommand label
name "fig:Simulated-Multicore-Architecture"

\end_inset

, our simulated baseline multicore system design consists of two OoO cores,
 a two-level cache hierarchy and a fixed-latency point-to-point on-chip
 interconnect.
 Both cache levels are lockup-free and store the state of outstanding requests
 via callbacks.
 Each of the private first-level split caches are currently implemented
 as write-back, but should be write-through with a coalescing store buffer.
 The shared second-level cache is write-back and maintains inclusion with
 respect to the first-level cache.
 Each cache maintains a on-chip directory.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename simulated_multicore_arch.pdf
	scale 63
	BoundingBox 28bp 242bp 570bp 580bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Overview of the Simulated Multicore System
\begin_inset CommandInset label
LatexCommand label
name "fig:fig:Simulated-Multicore-Architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Concept 1: Interface-Based Separation of Structural and Behavioral Modeling
\end_layout

\begin_layout Standard
The modeling of computer architecture can be classified into two types of
 modelings: structural modeling and behavioral modeling.
 Structural modeling refers to the modeling of static structural elements
 such as the internal structure of caches, whereas behavioral modeling refers
 to the modeling of dynamic behavioral elements such as the cache replacement
 policies and cache coherence protocols.
 
\end_layout

\begin_layout Standard
The complexity of multicore components and their interactions make it very
 hard to model the structural and behavioral aspects of modeling separately.
 Existing simulators written in traditional C or C++ programming languages
 inevitably makes the structural modeling elements are scattered among behaviora
l modeling elements.
 In other words, the structural modeling elements are entangled which means
 that its code is intermixed with code that implements behavioral modeling
 elements.
\end_layout

\begin_layout Standard
In order to solve the aforementioned problem of scattering and tangling
 of structural and behavioral aspects of architectural modeling, we use
 interface-based design methodology to abstract the implementation of structural
 elements, and use interfaces in place of concrete implementations of structural
 elements in the implementation of behavioral elements.
\end_layout

\begin_layout Subsection
Concept 2: Cycle-Accurate Callback-Based Eventing
\end_layout

\begin_layout Standard
As explained above, most Flexim modules implement an execution-driven simulation
, as SimpleScalar does.
 In such a model, function calls that activate some processor component
 (e.g., a cache or predictor) have an interface that receives a set of parameters
 and returns the latency needed to complete the access.
 Nevertheless, there are some situations where this latency is not a determinist
ic value and cannot be obtained in the instant when the function call is
 performed.
 Instead, it must be simulated cycle by cycle.
\end_layout

\begin_layout Standard
This is the case of interconnects and caches.
 In a generic topology, the delay of a message transference cannot be determined
 when the message is injected, because it depends on the dynamic network
 state.
 In addition, this state depends on future message transferences, so it
 cannot be computed unless advancing the simulation.
\end_layout

\begin_layout Standard
Because a cache access in a multithread-multicore environment may cause
 coherence messages transmitted across interconnection networks, the cache
 access latency cannot be estimated prior to the network access.
 In addition, the cache access latency can be affected by the internal state
 of accessed cache blocks, which is dynamically changed by cache writes
 and invalidates.
 Thus, the cache module is also implemented with an event-driven model.
 When the execution-driven simulator performs a cache access, it passes
 the handle of a callback method that specifies the action to be performed
 when the cache system completes the servicing of the cache access request.
\end_layout

\begin_layout Subsection
Simulating Out-of-Order Cores
\end_layout

\begin_layout Subsubsection
Behavioral Modeling
\end_layout

\begin_layout Standard
Flexim supports the mix of SMT and CMP simulation.
 As shown in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pipeline_arch"

\end_inset

, the simulated out-of-order pipeline is divided into five stages: 
\family typewriter
fetch
\family default
, 
\family typewriter
decode/rename/dispatch
\family default
, 
\family typewriter
issue
\family default
, 
\family typewriter
execute
\family default
, and 
\family typewriter
commit
\family default
.
 The buffers between pipeline stages such as decode buffer (
\family typewriter
DecodeBuffer
\family default
), reorder buffer (
\family typewriter
ReorderBuffer
\family default
) and load/store queue (
\family typewriter
LoadStoreQueue
\family default
) are explicitly modeled.
\end_layout

\begin_layout Standard
A set of parameters are provided to specify how the pipeline stages are
 organized in a multithreaded design.
 Stages can be shared among threads or private per thread.
 Moreover, when a stage is shared, there must be an algorithm which schedules
 a thread each cycle on the stage.
 The modeled pipe stages are described briefly as below.
\end_layout

\begin_layout Paragraph
The Five Pipeline Stages.
\end_layout

\begin_layout Enumerate
Fetch.
 The 
\family typewriter
fetch
\family default
 stage takes instructions from the L1 instruction cache and places them
 into a decode buffer.
 
\end_layout

\begin_layout Enumerate
Decode, Rename & Dispatch.
 The 
\family typewriter
decode/rename/dispatch
\family default
 stage takes instruction from a decode buffer, decodes them, maps architectural
 register dependencies (
\family typewriter
RegisterDependency
\family default
) into allocated physical registers (
\family typewriter
PhysicalRegister
\family default
), assigns them a reorder buffer entry and places them into a ready queue
 (
\family typewriter
ReadyQueue
\family default
) or a waiting queue (
\family typewriter
WaitingQueue
\family default
) depending on whether their input operands are available or not.
\end_layout

\begin_layout Enumerate
Issue.
 Then, the 
\family typewriter
issue
\family default
 stage consumes the instructions from the ready queue and sends them to
 the corresponding functional units, and the data cache is accessed for
 memory instructions.
\end_layout

\begin_layout Enumerate
Execute.
 During the 
\family typewriter
execute
\family default
 stage, the functional units operate and write their results into the register
 file.
 This stage is implicitly modeled in Flexim.
\end_layout

\begin_layout Enumerate
Commit.
 Finally, the 
\family typewriter
commit
\family default
 stage retires instructions from the reorder buffer in the program order.
 
\end_layout

\begin_layout Standard
This architecture is analogous to the one modeled by the SimpleScalar tool
 set, but uses a decode buffer, a reorder buffer and a few physical register
 files to replace an integrated 
\family typewriter
Register Update Unit
\family default
 (RUU).
 In the current implementation, the functional unit pool, physical register
 files, ready queue, waiting queue are shared among threads in a processor
 core; and the decode buffer, reorder buffer, and load/store queue are private
 per thread.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename processor.eps
	display false
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Overview of the Simulated Out-of-Order Processor Pipeline
\begin_inset CommandInset label
LatexCommand label
name "fig:pipeline_arch"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Structural Modeling
\end_layout

\begin_layout Paragraph
Physical Register File and Rename Table.
\end_layout

\begin_layout Standard
The integer, floating point and miscellaneous physical register files (
\family typewriter
PhysicalRegisterFile
\family default
) are modeled separately.
 All of them contain an array of physical registers (
\family typewriter
PhysicalRegister
\family default
s).
 Each of the physical registers can be in one of four states:
\end_layout

\begin_layout Enumerate
the physical register is free (
\family typewriter
PhysicalRegisterState.FREE
\family default
);
\end_layout

\begin_layout Enumerate
the physical register has been allocated to an instruction but has not been
 written to (
\family typewriter
PhysicalRegisterState.ALLOC
\family default
);
\end_layout

\begin_layout Enumerate
the physical register has been allocated to an instruction and the value
 has been written (
\family typewriter
PhysicalRegisterState.WB
\family default
);
\end_layout

\begin_layout Enumerate
the physical register is in the architectural state (
\family typewriter
PhysicalRegisterState.ARCH
\family default
).
\end_layout

\begin_layout Standard
Physical registers are allocated during instruction dispatch, and deallocated
 during instruction commit and reorder buffer recovery when branch misprediction
 is detected.
\end_layout

\begin_layout Standard
The integer, floating point and miscellaneous rename tables are modeled
 separately.
 They maintain the current mappings of each architectural register to a
 physical register.
 Each thread maintains its own rename table because it has its own set of
 architectural registers.
\end_layout

\begin_layout Paragraph
Functional Unit Pool.
\end_layout

\begin_layout Standard
The functional unit pool (
\family typewriter
FunctionalUnitPool
\family default
) is a collection of various categories of functional units (
\family typewriter
FunctionalUnit
\family default
s).
 Each category has a few number of functional units (specified by 
\family typewriter
quantity
\family default
), and has a fixed issue latency (
\family typewriter
issueLat
\family default
) and execution latency (
\family typewriter
execLat
\family default
).
 Each of the functional units can be one of two states (indicated by 
\family typewriter
busy
\family default
):
\end_layout

\begin_layout Enumerate
the functional unit is free (
\family typewriter
busy
\family default
 is set to false);
\end_layout

\begin_layout Enumerate
the functional unit has been allocated to execute an instruction (
\family typewriter
busy
\family default
 is set to true).
\end_layout

\begin_layout Standard
Upon instruction issue, the funcitonal unit pool is queried to find a free
 functional unit of the specified functional unit category (
\family typewriter
FunctionalUnitType
\family default
) for a ready instruction from the ready queue.
 If a free functional unit is found, the instruction is issued.
 Otherwise, the instruction is pushed back into the ready queue.
\end_layout

\begin_layout Paragraph
Branch Predictors.
\end_layout

\begin_layout Standard
Branch predictors provides the prediction of branch direction and targets.
 The branch predictors in Flexim.
 are modeled after Marss86.
 Three kinds of branch predictors (interface 
\family typewriter
Bpred
\family default
) are implemented: the bimod predictor (
\family typewriter
BimodBpredDir
\family default
), the two level predictor (
\family typewriter
TwoLevelBpredDir
\family default
) and the combined predictor (
\family typewriter
TwoLevelBpredDir
\family default
).
 Separate branch predictors are implemented per thread.
\end_layout

\begin_layout Paragraph
Decode Buffer.
\end_layout

\begin_layout Standard
The decode buffer is used as a FIFO queue between the instruction fetch
 stage and the decode/rename/dispatch stage.
\end_layout

\begin_layout Paragraph
Reorder Buffers.
\end_layout

\begin_layout Standard
In order to maintain the correct ordering of the commtted instructions,
 the reorder buffer is explicitly modeled as a FIFO (First-In-First-Out)
 buffer.
 Its entries (
\family typewriter
ReorderBufferEntry
\family default
) are pushed during instruction dispatch and are popped in the program order
 during instruction commit.
\end_layout

\begin_layout Paragraph
load/store queues.
\end_layout

\begin_layout Standard
Loads and store access the L1 data cache shared among threads within a core.
 In order to keep track of pending memory accesses, the load/store queue
 (
\family typewriter
LoadStoreQueue
\family default
) is used.
 Separate load/store queue is maintained per thread, so that an unresolved
 address from one thread does not prevent loads in other threads from issuing.
\end_layout

\begin_layout Subsection
Simulating Multi-Level Cache Hierarchies
\end_layout

\begin_layout Standard
A two-level cache hierarchy is modeled for the moment.
 Cache coherence is enforced with the directory-based MESI protocol between
 the private level one caches owned by each core and the level two cache
 that shared among cores.
\end_layout

\begin_layout Standard
Currently, constant-latency on-chip interconnect is modeled, the cycle-accurate
 simulation of on-chip interconnect and DRAM access is left as future work.
 The integration of DRAMSim with Flexim is planned.
\end_layout

\begin_layout Subsubsection
Structural Modeling
\end_layout

\begin_layout Standard
Besides the data, tag, and state, a cache block has a corresponding directory
 entry that contains the owner and sharers information of the block.
 The geometry parameters of each cache in the memory hierarchy are configured
 via XML files.
 The cache subblock granularity is currently not supported but planned for
 future work.
 The LRU cache replacement policy is implemented for the moment, the implementat
ions of more advanced policies are left as future work.
\end_layout

\begin_layout Paragraph
Cache.
 
\end_layout

\begin_layout Standard
Each cache (
\family typewriter
Cache
\family default
) can be partitioned into a number of sets (
\family typewriter
CacheSet
\family default
s), the number of sets in a cache is defined by the parameter 
\family typewriter
numSets
\family default
.
 And each set can be partitioned further into a few blocks (
\family typewriter
CacheBlock
\family default
s), the number of bloks in a set is defined by the parameter 
\family typewriter
assoc
\family default
 (associativity).
 And the cache replacement policy tries to select a victim cache block within
 a set to evict when the requesting cache block is being brought from the
 lower cache hierarchy.
\end_layout

\begin_layout Paragraph
Directory.
\end_layout

\begin_layout Standard
Each cache maintains its own directory (
\family typewriter
Dir
\family default
) which is a set of directory entries (
\family typewriter
DirEntry
\family default
s).
 Each directory entry keeps the track of owner and sharer information for
 the associated cache block or subblock, depending on the availability of
 subblock modeling.
\end_layout

\begin_layout Subsubsection
Behavioral Modeling
\end_layout

\begin_layout Paragraph
Cache Coherence (Directory Based MESI as an Example).
\end_layout

\begin_layout Standard
A directory based MESI cache coherence protocol running on a simple fixed-latenc
y point-to-point interconnect is modeled for the moment.
 the cache block state transition diagram is shown in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Directory-based-MESI"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename mesi_dir_cc_protocol.pdf
	scale 60
	BoundingBox 60bp 80bp 700bp 580bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Directory based MESI Cache Coherence
\begin_inset CommandInset label
LatexCommand label
name "fig:Directory-based-MESI"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
In progress.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
In progress.
\end_layout

\begin_layout Itemize
Further works
\end_layout

\begin_deeper
\begin_layout Itemize
Functional simulation: parallel workload support
\end_layout

\end_deeper
\begin_layout Section*
Acknowledgments
\end_layout

\begin_layout Standard
This work was supported by the Ministry of Education of China-Intel Special
 Research Foundation for Information Technology program under the contract
 No.
 MOE-INTEL-08-10.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/home/itecgo/research/refs_classfied/default"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
