#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{graphicx}
\usepackage{color}
\usepackage{moreverb}
\usepackage{multirow}
\usepackage{makeidx}
\usepackage{array}
\usepackage{longtable}


\renewcommand{\baselinestretch}{1}
\end_preamble
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing onehalf
\use_hyperref true
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
The Flexim User Guide
\begin_inset Newline newline
\end_inset


\size footnotesize
(
\color red
Pre-release, Documentation-in-Progress
\color inherit
)
\end_layout

\begin_layout Author
Min Cai <
\begin_inset CommandInset href
LatexCommand href
target "itecgo@163.com"
type "mailto:"

\end_inset

>
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Beijing Institute of Technology
\begin_inset Newline newline
\end_inset

Beijing, China
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Welcome to Flexim! Flexim is an open-source, modular and highly configurable
 architectural simulator for evaluating emerging multicore processors.
 It can run statically compiled MIPS32 Little-Endian (LE) programs.
 
\end_layout

\begin_layout Standard
For the latest Flexim code, please visit the project's website on Github:
 
\begin_inset CommandInset href
LatexCommand href
target "http://github.com/mcai/flexim"

\end_inset

.
 
\end_layout

\begin_layout Section
Key Features
\end_layout

\begin_layout Enumerate
Architectural
\end_layout

\begin_deeper
\begin_layout Itemize
Simulation of a classic five-stage superscalar pipeline with out-of-order
 execution.
 
\end_layout

\begin_layout Itemize
Multi-level memory hierarchy with the directory-based MESI cache coherence
 protocol.
 
\end_layout

\begin_layout Itemize
Support for Syscall-emulation mode simulation (i.e., application only, no
 need to boot an OS).
 
\end_layout

\begin_layout Itemize
Correct execution of several state-of-the-art benchmark suites, e.g., wcet_bench,
 Olden and CPU2006.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Non-architectural
\end_layout

\begin_deeper
\begin_layout Itemize
Developed from scratch in the object-oriented system programming language
 D 2.0.
 Great efforts are made to advocate software engineering practices in the
 simulator construction.
 
\end_layout

\begin_layout Itemize
A powerful infrastructure that provides common functionalities such as eventing,
 logging and XML I/O.
 
\end_layout

\begin_layout Itemize
Pervasive use of XML-based I/O for architectural, workload and experiment
 configurations and statistics.
 
\end_layout

\begin_layout Itemize
Easy to use.
 No scripting.
 Only required are a statically compiled simulator executable and a few
 XML files.
 
\end_layout

\end_deeper
\begin_layout Section
Development Progress
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Main Category
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Current Progress
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Functional Simulation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Int.
 Inst.
 Decoding & Execution
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OK for wcet-bench, mst, em3d, etc.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fp.
 Inst.
 Decoding & Execution
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OK for wcet-bench, mst, em3d, etc.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
System Call Emulation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OK for wcet-bench, mst, em3d, etc.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MIPS LE ELF Exe.
 Loader
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Can run statically compiled programs
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Performance Simulation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Processor core
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Being rewritten; almost complete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Set-associative cache structure
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OK
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cache coherence
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Being rewritten; almost complete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
On-chip interconnect
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Planned
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interface to external DRAM simulators
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
To be planned
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Supporting Infrastructure
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eventing and callback mechanisms
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OK, pervasive use in existing code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Categorized logging mechanism
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OK, limited use in existing code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
XML-based I/O for configs and stats 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OK
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Plotting and table generation for experiments
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Planned
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
System Requirements
\end_layout

\begin_layout Enumerate
Make sure that you have a Ubuntu 10.04 Linux machine.
 Other popular Linux distributions may work as well if you are lucky enough.
 
\end_layout

\begin_layout Enumerate
Make sure that you have the latest DMD 2.0 compiler installed.
 If not, go to this page and download "dmd D 2.0 compiler 1-click install
 for Ubuntu": 
\begin_inset CommandInset href
LatexCommand href
target "http://www.digitalmars.com/d/download.html"

\end_inset

.
\end_layout

\begin_layout Section
How to Build and Run Flexim
\end_layout

\begin_layout Enumerate
Unpack the zip or tar file containing the Flexim source.
 
\end_layout

\begin_layout Enumerate
In the main directory of the distribution, you can 
\end_layout

\begin_deeper
\begin_layout Itemize
build Flexim using the command: '
\family typewriter
make
\family default
';
\end_layout

\begin_layout Itemize
remove all the built files using the command: '
\family typewriter
make clean
\family default
'.
 
\end_layout

\begin_layout Standard
By default, the flexim binary is placed in the bin/ folder.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Download and unpack cross-compiler-mipsel.tar.bz2 from 
\begin_inset CommandInset href
LatexCommand href
target "http://github.com/mcai/flexim/downloads/"

\end_inset

.
 Use it to compile MIPS32 LE programs to be simulated by Flexim.
 
\end_layout

\begin_layout Enumerate
In the subdirectory build/, you can start simulation with the default simulation
 configuration using the command: 
\begin_inset Quotes eld
\end_inset


\family typewriter
./flexim
\family default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\family typewriter
./flexim --experiment=<experiment-name>
\family default

\begin_inset Quotes erd
\end_inset

.
 Benchmarks and experiments are specified in the subdirectory configs/benchmarks
/ and configs/experiments/, respectively.
\end_layout

\begin_layout Enumerate
You can find configuration and statistics files in the configs/ and stats/
 subdirectories, respectively.
 Some sample XML files are provided for your reference.
\end_layout

\begin_layout Enumerate
Useful tip: As with all other open source projects, you can learn more by
 digging into the Flexim source code.
\end_layout

\begin_layout Section
The Structure of the File
\end_layout

\begin_layout Standard
The whole development of the Flexim simulator encompasses three main categories
 of functionalities: functional simulation, performance simulation and the
 supporting infrastructure.
 Chapter 2 focuses on functional simulation.
 Chapter 3 elaborates on performance simulation.
 Chapter 4 focuses on the supporting infrastructure.
 And Chapter 5 provides the evaluation, limitations and future work of Flexim.
\end_layout

\begin_layout Chapter
Functional Simulation
\end_layout

\begin_layout Standard
Functional simulation encompasses the abilities to load and parse MIPS binaries,
 decode and execute instructions, and emulate system calls.
\end_layout

\begin_layout Section
ELF-Formatted MIPS Little-Endian Executable Loader
\end_layout

\begin_layout Standard
The Executable and Linkable Format (ELF) is a standard binary file format
 for Unix and Unix-like (such as Linux) systems.
 Each ELF file is made up of one ELF header, followed by file data.
 The file data can include:
\end_layout

\begin_layout Itemize
Program header table, describing zero or more segments
\end_layout

\begin_layout Itemize
Section header table, describing zero or more sections
\end_layout

\begin_layout Itemize
Data referred to by entries in the program header table or section header
 table
\end_layout

\begin_layout Standard
The segments contain information that is necessary for runtime execution
 of the file, while sections contain important data for linking and relocation.
 Each byte in the entire file is taken by no more than one section at a
 time, but there can be orphan bytes, which are not covered by a section.
 In the normal case of a Unix executable one or more sections are enclosed
 in one segment.
\end_layout

\begin_layout Standard
In Flexim, the tasks of loading and parsing of ELF files are done through
 the classes 
\family typewriter
ELFReader
\family default
 and 
\family typewriter
ELF32Binary
\family default
 and a few supporting code elements.
 Each process in Flexim is associated with one 
\family typewriter
ELF32Binary
\family default
 object.
\end_layout

\begin_layout Section
Instruction Decoding and Execution
\end_layout

\begin_layout Standard
In Flexim, there are two kinds of instructions, i.e., static instructions
 and dynamic instructions.
 A static instruction represents a decoded instruction that fetched from
 memory, and a dynamic instruction represents a dynamically-scheduled instructio
n.
 
\end_layout

\begin_layout Standard
Below are the details of the implemented instructions.
\end_layout

\begin_layout Subsection
Basic Instructions
\end_layout

\begin_layout Enumerate
nop.
 It does nothing.
\end_layout

\begin_layout Enumerate
syscall.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.syscall(thread.intRegs[2]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sll.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = thread.intRegs[this[RT]] << this[SA];
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sllv.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = thread.intRegs[this[RT]] << bits(thread.intRegs[this[RS]
], 4, 0);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sra.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = cast(int) thread.intRegs[this[RT]] >> this[SA];
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
srav.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = cast(int) thread.intRegs[this[RT]]
\end_layout

\begin_layout Plain Layout

				>> bits(thread.intRegs[this[RS]], 4, 0);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
srl.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = cast(uint) thread.intRegs[this[RT]] >> this[SA];
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
srlv.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = cast(uint) thread.intRegs[this[RT]]
\end_layout

\begin_layout Plain Layout

				>> bits(thread.intRegs[this[RS]], 4, 0);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Branching Instructions
\end_layout

\begin_layout Enumerate
Common operations found in the implementation of branching operations.
\begin_inset Newline newline
\end_inset

The displacement calculation is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.displacement = sext(this[OFFSET] << 2, 16);
\end_layout

\end_inset

And the branching function is shown as below: 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.nnpc = thread.npc + this.displacement;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
b.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.branch(thread);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bal.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[ReturnAddressReg] = thread.nnpc;
\end_layout

\begin_layout Plain Layout

this.branch(thread);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
beq.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

if(cast(int) thread.intRegs[this[RS]] == cast(int) thread.intRegs[this[RT]])
 {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
beqz.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

if(cast(int) thread.intRegs[this[RS]] == 0) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bgez.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

if(cast(int) thread.intRegs[this[RS]] >= 0) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bgezal.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[ReturnAddressReg] = thread.nnpc;
\end_layout

\begin_layout Plain Layout

if(cast(int) thread.intRegs[this[RS]] >= 0) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bgtz.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

if(cast(int) thread.intRegs[this[RS]] > 0) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
blez.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

if(cast(int) thread.intRegs[this[RS]] <= 0) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bltz.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

if(cast(int) thread.intRegs[this[RS]] < 0) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bltzal.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[ReturnAddressReg] = thread.nnpc;
\end_layout

\begin_layout Plain Layout

if(cast(int) thread.intRegs[this[RS]] < 0) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bne.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

if(cast(int) thread.intRegs[this[RS]] != cast(int) thread.intRegs[this[RT]])
 {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bnez.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

if(cast(int) thread.intRegs[this[RS]] != 0) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bc1f.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint fcsr = thread.miscRegs.fcsr;
\end_layout

\begin_layout Plain Layout

bool cond = getFCC(fcsr, this[BRANCH_CC]) == 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(cond) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bc1t.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint fcsr = thread.miscRegs.fcsr;
\end_layout

\begin_layout Plain Layout

bool cond = getFCC(fcsr, this[BRANCH_CC]) == 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(cond) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bc1fl.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint fcsr = thread.miscRegs.fcsr;
\end_layout

\begin_layout Plain Layout

bool cond = getFCC(fcsr, this[BRANCH_CC]) == 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(cond) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	thread.npc = thread.nnpc;
\end_layout

\begin_layout Plain Layout

	thread.nnpc = thread.nnpc + uint.sizeof;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
bc1tl.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint fcsr = thread.miscRegs.fcsr;
\end_layout

\begin_layout Plain Layout

bool cond = getFCC(fcsr, this[BRANCH_CC]) == 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(cond) {
\end_layout

\begin_layout Plain Layout

	this.branch(thread);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	thread.npc = thread.nnpc;
\end_layout

\begin_layout Plain Layout

	thread.nnpc = thread.nnpc + uint.sizeof;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Jumping Instructions
\end_layout

\begin_layout Enumerate
Common operations found in the implementation of jumping operations.
\begin_inset Newline newline
\end_inset

The abstract definition of target PC calculation is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

abstract uint targetPc(Thread thread);
\end_layout

\end_inset

And the jumping function is shown as below: 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.nnpc = addr;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
j.
\begin_inset Newline newline
\end_inset

Its target PC calculation is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

return mbits(thread.npc, 32, 28) | this.target;
\end_layout

\end_inset

Its execution logic is shown as below: 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.jump(thread, this.targetPc(thread));
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
jal.
\begin_inset Newline newline
\end_inset

Its target PC calculation is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

return mbits(thread.npc, 32, 28) | this.target;
\end_layout

\end_inset

Its execution logic is shown as below: 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[ReturnAddressReg] = thread.nnpc;
\end_layout

\begin_layout Plain Layout

this.jump(thread, this.targetPc(thread));
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
jalr.
\begin_inset Newline newline
\end_inset

Its target PC calculation is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

return thread.intRegs[this[RS]];
\end_layout

\end_inset

Its execution logic is shown as below: 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = thread.nnpc;
\end_layout

\begin_layout Plain Layout

this.jump(thread, this.targetPc(thread));
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
jr.
\begin_inset Newline newline
\end_inset

Its target PC calculation is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

return thread.intRegs[this[RS]];
\end_layout

\end_inset

Its execution logic is shown as below: 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.jump(thread, this.targetPc(thread));
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Floating Point Arithmetic Instructions
\end_layout

\begin_layout Enumerate
add_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

double ft = thread.floatRegs.getDouble(this[FT]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

double fd = fs + ft;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sub_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

double ft = thread.floatRegs.getDouble(this[FT]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

double fd = fs - ft;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mul_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

double ft = thread.floatRegs.getDouble(this[FT]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

double fd = fs * ft;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
div_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

double ft = thread.floatRegs.getDouble(this[FT]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

double fd = fs / ft;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sqrt_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

double fd = sqrt(fs);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
abs_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

double fd = fabs(fs);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
neg_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

double fd = -1 * fs;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mov_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

double fd = fs;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
add_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

float ft = thread.floatRegs.getFloat(this[FT]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

float fd = fs + ft;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sub_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

float ft = thread.floatRegs.getFloat(this[FT]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

float fd = fs - ft;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mul_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

float ft = thread.floatRegs.getFloat(this[FT]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

float fd = fs * ft;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
div_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

float ft = thread.floatRegs.getFloat(this[FT]);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

float fd = fs / ft;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sqrt_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

float fd = sqrt(fs);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
abs_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

float fd = fabs(fs);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
neg_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

float fd = -fs;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mov_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

float fd = fs;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cvt_d_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

double fd = cast(double) fs;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cvt_w_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

uint fd = cast(uint) fs;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setUint(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cvt_l_s.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

ulong fd = cast(ulong) fs;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setUlong(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cvt_s_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

float fd = cast(float) fs;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cvt_w_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

uint fd = cast(uint) fs;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setUint(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cvt_l_d.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

ulong fd = cast(ulong) fs;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setUlong(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cvt_s_w.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint fs = thread.floatRegs.getUint(this[FS]);
\end_layout

\begin_layout Plain Layout

float fd = cast(float) fs;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cvt_d_w.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint fs = thread.floatRegs.getUint(this[FS]);
\end_layout

\begin_layout Plain Layout

double fd = cast(double) fs;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cvt_s_l.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

ulong fs = thread.floatRegs.getUlong(this[FS]);
\end_layout

\begin_layout Plain Layout

float fd = cast(float) fs;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setFloat(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cvt_d_l.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

ulong fs = thread.floatRegs.getUlong(this[FS]);
\end_layout

\begin_layout Plain Layout

double fd = cast(double) fs;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.floatRegs.setDouble(fd, this[FD]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
c_<cond>_d type instructions, which include c_f_d, c_un_d, c_eq_d, c_ueq_d,
 c_olt_d, c_ult_d, c_ole_d, c_ule_d, c_sf_d, c_ngle_d, c_seq_d, c_ngl_d,
 c_lt_d, c_nge_d, c_le_d and c_ngt_d.
 The execution logic of this type of instructions is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

double fs = thread.floatRegs.getDouble(this[FS]);
\end_layout

\begin_layout Plain Layout

double ft = thread.floatRegs.getDouble(this[FT]);
\end_layout

\begin_layout Plain Layout

uint fcsr = thread.miscRegs.fcsr;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

bool less;
\end_layout

\begin_layout Plain Layout

bool equal;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool unordered = isnan(fs) || isnan(ft);
\end_layout

\begin_layout Plain Layout

if(unordered) {
\end_layout

\begin_layout Plain Layout

	equal = false;
\end_layout

\begin_layout Plain Layout

	less = false;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	equal = fs == ft;
\end_layout

\begin_layout Plain Layout

	less = fs < ft;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint cond = this[COND];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(((cond&0x4) && less)||((cond&0x2) && equal)||((cond&0x1) && unordered))
 {
\end_layout

\begin_layout Plain Layout

	setFCC(fcsr, this[CC]);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	clearFCC(fcsr, this[CC]);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.miscRegs.fcsr = fcsr;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
c_<cond>_s type instructions, which include c_f_s, c_un_s, c_eq_s, c_ueq_s,
 c_olt_s, c_ult_s, c_ole_s, c_ule_s, c_sf_s, c_ngle_s, c_seq_s, c_ngl_s,
 c_lt_s, c_nge_s, c_le_s and c_ngt_s.
 The execution logic of this type of instructions is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

float fs = thread.floatRegs.getFloat(this[FS]);
\end_layout

\begin_layout Plain Layout

float ft = thread.floatRegs.getFloat(this[FT]);
\end_layout

\begin_layout Plain Layout

uint fcsr = thread.miscRegs.fcsr;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

bool less;
\end_layout

\begin_layout Plain Layout

bool equal;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool unordered = isnan(fs) || isnan(ft);
\end_layout

\begin_layout Plain Layout

if(unordered) {
\end_layout

\begin_layout Plain Layout

	equal = false;
\end_layout

\begin_layout Plain Layout

	less = false;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	equal = fs == ft;
\end_layout

\begin_layout Plain Layout

	less = fs < ft;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint cond = this[COND];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(((cond&0x4) && less)||((cond&0x2) && equal)||((cond&0x1) && unordered))
 {
\end_layout

\begin_layout Plain Layout

	setFCC(fcsr, this[CC]);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	clearFCC(fcsr, this[CC]);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.miscRegs.fcsr = fcsr;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mfc1.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint fs = thread.floatRegs.getUint(this[FS]);
\end_layout

\begin_layout Plain Layout

thread.intRegs[this[RT]] = fs;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
cfc1.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint fcsr = thread.miscRegs.fcsr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint rt = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(this[FS] == 31) {
\end_layout

\begin_layout Plain Layout

	rt = fcsr;
\end_layout

\begin_layout Plain Layout

	thread.intRegs[this[RT]] = rt;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mtc1.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint rt = thread.intRegs[this[RT]];
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setUint(rt, this[FS]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
ctc1.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint rt = thread.intRegs[this[RT]];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(this[FS]) {
\end_layout

\begin_layout Plain Layout

	thread.miscRegs.fcsr = rt;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Integer Arithmetic Instructions
\end_layout

\begin_layout Enumerate
Common operations found in the implementation of integer arithmetic operations.
\begin_inset Newline newline
\end_inset

Its immmediate value is calculated as:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.imm = cast(short) machInst[INTIMM];
\end_layout

\end_inset

Its zero-extended immediate value is calculated as:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.zextImm = 0x0000FFFF & machInst[INTIMM];
\end_layout

\end_inset

Its sign-extended immediate value is calculated as:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.sextImm = sext(machInst[INTIMM], 16);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
add.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = cast(int) thread.intRegs[this[RS]]
\end_layout

\begin_layout Plain Layout

				+ cast(int) thread.intRegs[this[RT]];
\end_layout

\begin_layout Plain Layout

logging.warn(LogCategory.INSTRUCTION, "Add: overflow trap not implemented.");
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
addi.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RT]] = cast(int) thread.intRegs[this[RS]] + this.sextImm;
\end_layout

\begin_layout Plain Layout

logging.warn(LogCategory.INSTRUCTION, "Addi: overflow trap not implemented.");
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
addiu.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RT]] = cast(int) thread.intRegs[this[RS]] + this.sextImm;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
addu.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = cast(int) thread.intRegs[this[RS]]
\end_layout

\begin_layout Plain Layout

				+ cast(int) thread.intRegs[this[RT]];
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sub.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = cast(int) thread.intRegs[this[RS]]
\end_layout

\begin_layout Plain Layout

				- cast(int) thread.intRegs[this[RT]];
\end_layout

\begin_layout Plain Layout

logging.warn(LogCategory.INSTRUCTION, "Sub: overflow trap not implemented.");
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
subu.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = cast(int) thread.intRegs[this[RS]]
\end_layout

\begin_layout Plain Layout

				- cast(int) thread.intRegs[this[RT]];
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
and.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = thread.intRegs[this[RS]] & thread.intRegs[this[RT]];
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
andi.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RT]] = thread.intRegs[this[RS]] & this.zextImm;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
nor.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = ~(thread.intRegs[this[RS]] | thread.intRegs[this[RT]]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
or.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = thread.intRegs[this[RS]] | thread.intRegs[this[RT]];
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
ori.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RT]] = thread.intRegs[this[RS]] | this.zextImm;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
xor.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = thread.intRegs[this[RS]] ^ thread.intRegs[this[RT]];
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
xori.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RT]] = thread.intRegs[this[RS]] ^ this.zextImm;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
slt.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = cast(int) thread.intRegs[this[RS]]
\end_layout

\begin_layout Plain Layout

				< cast(int) thread.intRegs[this[RT]] ? 1 : 0;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
slti.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RT]] = cast(int) thread.intRegs[this[RS]] < this.sextImm
 ? 1 : 0;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sltiu.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RT]] = cast(uint) thread.intRegs[this[RS]] < this.zextImm
 ? 1 : 0;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sltu.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = cast(uint) thread.intRegs[this[RS]]
\end_layout

\begin_layout Plain Layout

				< cast(uint) thread.intRegs[this[RT]] ? 1 : 0;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
lui.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RT]] = this.imm << 16;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
divu.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

ulong rs = 0;
\end_layout

\begin_layout Plain Layout

ulong rt = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint lo = 0;
\end_layout

\begin_layout Plain Layout

uint hi = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rs = thread.intRegs[this[RS]];
\end_layout

\begin_layout Plain Layout

rt = thread.intRegs[this[RT]];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(rt != 0) {
\end_layout

\begin_layout Plain Layout

	lo = cast(uint) (rs / rt);
\end_layout

\begin_layout Plain Layout

	hi = cast(uint) (rs % rt);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.miscRegs.lo = lo;
\end_layout

\begin_layout Plain Layout

thread.miscRegs.hi = hi;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
div.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

long rs = 0;
\end_layout

\begin_layout Plain Layout

long rt = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint lo = 0;
\end_layout

\begin_layout Plain Layout

uint hi = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rs = sext(thread.intRegs[this[RS]], 32);
\end_layout

\begin_layout Plain Layout

rt = sext(thread.intRegs[this[RT]], 32);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(rt != 0) {
\end_layout

\begin_layout Plain Layout

	lo = cast(uint) (rs / rt);
\end_layout

\begin_layout Plain Layout

	hi = cast(uint) (rs % rt);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.miscRegs.lo = lo;
\end_layout

\begin_layout Plain Layout

thread.miscRegs.hi = hi;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mflo.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = thread.miscRegs.lo;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mfhi.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.intRegs[this[RD]] = thread.miscRegs.hi;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mtlo.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.miscRegs.lo = thread.intRegs[this[RD]];
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mthi.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

thread.miscRegs.hi = thread.intRegs[this[RD]];
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
mult.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

long rs = 0;
\end_layout

\begin_layout Plain Layout

long rt = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rs = sext(thread.intRegs[this[RS]], 32);
\end_layout

\begin_layout Plain Layout

rt = sext(thread.intRegs[this[RT]], 32);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

long val = rs * rt;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint lo = cast(uint) bits64(val, 31, 0);
\end_layout

\begin_layout Plain Layout

uint hi = cast(uint) bits64(val, 63, 32);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.miscRegs.lo = lo;
\end_layout

\begin_layout Plain Layout

thread.miscRegs.hi = hi;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
multu.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

ulong rs = 0;
\end_layout

\begin_layout Plain Layout

ulong rt = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rs = thread.intRegs[this[RS]];
\end_layout

\begin_layout Plain Layout

rt = thread.intRegs[this[RT]];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ulong val = rs * rt;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint lo = cast(uint) bits64(val, 31, 0);
\end_layout

\begin_layout Plain Layout

uint hi = cast(uint) bits64(val, 63, 32);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.miscRegs.lo = lo;
\end_layout

\begin_layout Plain Layout

thread.miscRegs.hi = hi;
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Memory Access Instructions
\end_layout

\begin_layout Enumerate
Common operations found in the implementation of memory access operations.
\begin_inset Newline newline
\end_inset

Its displacement value is calculated as:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.displacement = sext(machInst[OFFSET], 16);
\end_layout

\end_inset

And its effective address is calculated as (overridable):
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

return thread.intRegs[this[RS]] + this.displacement;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
lb.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

byte mem = 0;
\end_layout

\begin_layout Plain Layout

thread.mem.readByte(this.ea(thread), cast(ubyte*) &mem);
\end_layout

\begin_layout Plain Layout

thread.intRegs[this[RT]] = mem;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
lbu.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

ubyte mem = 0;
\end_layout

\begin_layout Plain Layout

thread.mem.readByte(this.ea(thread), &mem);
\end_layout

\begin_layout Plain Layout

thread.intRegs[this[RT]] = mem;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
lh.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

short mem = 0;
\end_layout

\begin_layout Plain Layout

thread.mem.readHalfWord(this.ea(thread), cast(ushort*) &mem);
\end_layout

\begin_layout Plain Layout

thread.intRegs[this[RT]] = mem;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
lhu.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

ushort mem = 0;
\end_layout

\begin_layout Plain Layout

thread.mem.readHalfWord(this.ea(thread), &mem);
\end_layout

\begin_layout Plain Layout

thread.intRegs[this[RT]] = mem;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
lw.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

int mem = 0;
\end_layout

\begin_layout Plain Layout

thread.mem.readWord(this.ea(thread), cast(uint*) &mem);
\end_layout

\begin_layout Plain Layout

thread.intRegs[this[RT]] = mem;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
lwl.
\begin_inset Newline newline
\end_inset

Its overriden effective address calculation is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint addr = thread.intRegs[this[RS]] + this.displacement;
\end_layout

\begin_layout Plain Layout

return addr & ~3;
\end_layout

\end_inset

 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint addr = thread.intRegs[this[RS]] + this.displacement;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint ea = addr & ~3;
\end_layout

\begin_layout Plain Layout

uint byte_offset = addr & 3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint mem = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.mem.readWord(ea, &mem);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint mem_shift = 24 - 8 * byte_offset;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint rt = (mem << mem_shift) | (thread.intRegs[this[RT]] & mask(mem_shift));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.intRegs[this[RT]] = rt;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
lwr.
\begin_inset Newline newline
\end_inset

Its overriden effective address calculation is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint addr = thread.intRegs[this[RS]] + this.displacement;
\end_layout

\begin_layout Plain Layout

return addr & ~3;
\end_layout

\end_inset

Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint addr = thread.intRegs[this[RS]] + this.displacement;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint ea = addr & ~3;
\end_layout

\begin_layout Plain Layout

uint byte_offset = addr & 3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint mem = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.mem.readWord(ea, &mem);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint mem_shift = 8 * byte_offset;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint rt = (thread.intRegs[this[RT]] & (mask(mem_shift) << (32 - mem_shift)))
\end_layout

\begin_layout Plain Layout

				| (mem >> mem_shift);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.intRegs[this[RT]] = rt;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
ll.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint mem = 0;		
\end_layout

\begin_layout Plain Layout

thread.mem.readWord(this.ea(thread), &mem);		
\end_layout

\begin_layout Plain Layout

thread.intRegs[this[RT]] = mem;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
lwc1.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint mem = 0;
\end_layout

\begin_layout Plain Layout

thread.mem.readWord(this.ea(thread), &mem);			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setUint(mem, this[FT]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
ldc1.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

ulong mem = 0;
\end_layout

\begin_layout Plain Layout

thread.mem.readDoubleWord(this.ea(thread), &mem);			
\end_layout

\begin_layout Plain Layout

thread.floatRegs.setUlong(mem, this[FT]);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sb.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

ubyte mem = cast(ubyte) bits(thread.intRegs[this[RT]], 7, 0);
\end_layout

\begin_layout Plain Layout

thread.mem.writeByte(this.ea(thread), mem);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sh.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

ushort mem = cast(ushort) bits(thread.intRegs[this[RT]], 15, 0);
\end_layout

\begin_layout Plain Layout

thread.mem.writeHalfWord(this.ea(thread), mem);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sw.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint mem = thread.intRegs[this[RT]];
\end_layout

\begin_layout Plain Layout

thread.mem.writeWord(this.ea(thread), mem);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
swl.
\begin_inset Newline newline
\end_inset

Its overriden effective address calculation is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint addr = thread.intRegs[this[RS]] + this.displacement;
\end_layout

\begin_layout Plain Layout

return addr & ~3;
\end_layout

\end_inset

Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint addr = thread.intRegs[this[RS]] + this.displacement;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint ea = addr & ~3;
\end_layout

\begin_layout Plain Layout

uint byte_offset = addr & 3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint mem = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.mem.readWord(ea, &mem);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint reg_shift = 24 - 8 * byte_offset;
\end_layout

\begin_layout Plain Layout

uint mem_shift = 32 - reg_shift;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mem = (mem & (mask(reg_shift) << mem_shift)) | (thread.intRegs[this[RT]]
 >> reg_shift);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.mem.writeWord(ea, mem);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
swr.
\begin_inset Newline newline
\end_inset

Its overriden effective address calculation is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint addr = thread.intRegs[this[RS]] + this.displacement;
\end_layout

\begin_layout Plain Layout

return addr & ~3;
\end_layout

\end_inset

Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint addr = thread.intRegs[this[RS]] + this.displacement;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint ea = addr & ~3;
\end_layout

\begin_layout Plain Layout

uint byte_offset = addr & 3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint mem = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.mem.readWord(ea, &mem);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint reg_shift = 8 * byte_offset;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mem = thread.intRegs[this[RT]] << reg_shift | (mem & (mask(reg_shift)));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

thread.mem.writeWord(ea, mem);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sc.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint rt = thread.intRegs[this[RT]];
\end_layout

\begin_layout Plain Layout

thread.mem.writeWord(this.ea(thread), rt);
\end_layout

\begin_layout Plain Layout

thread.intRegs[this[RT]] = 1;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
swc1.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint ft = thread.floatRegs.getUint(this[FT]);			
\end_layout

\begin_layout Plain Layout

thread.mem.writeWord(this.ea(thread), ft);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
sdc1.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

ulong ft = thread.floatRegs.getUlong(this[FT]);			
\end_layout

\begin_layout Plain Layout

thread.mem.writeDoubleWord(this.ea(thread), ft);
\end_layout

\end_inset


\end_layout

\begin_layout Section
System Call Emulation
\end_layout

\begin_layout Standard
A few system calls are emulated for the correct execution of the whole wcet_benc
h benchmark suite, and mst and em3d from the Olden benchmark suite.
\end_layout

\begin_layout Enumerate
exit.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

logging.haltf(LogCategory.SYSCALL, "target called exit(%d)", thread.getSyscallArg(0
) & 0xff);
\end_layout

\begin_layout Plain Layout

return 1;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
read.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

int fd = thread.getSyscallArg(0);
\end_layout

\begin_layout Plain Layout

uint buf_addr = thread.getSyscallArg(1);
\end_layout

\begin_layout Plain Layout

size_t count = thread.getSyscallArg(2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void* buf = malloc(count);
\end_layout

\begin_layout Plain Layout

ssize_t ret = core.sys.posix.unistd.read(fd, buf, count);
\end_layout

\begin_layout Plain Layout

if(ret > 0) {
\end_layout

\begin_layout Plain Layout

	thread.mem.writeBlock(buf_addr, ret, cast(ubyte*) buf);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

free(buf);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return ret;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
write.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

int fd = thread.getSyscallArg(0);
\end_layout

\begin_layout Plain Layout

uint buf_addr = thread.getSyscallArg(1);
\end_layout

\begin_layout Plain Layout

size_t count = thread.getSyscallArg(2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void* buf = malloc(count);
\end_layout

\begin_layout Plain Layout

thread.mem.readBlock(buf_addr, count, cast(ubyte*) buf);
\end_layout

\begin_layout Plain Layout

ssize_t ret = core.sys.posix.unistd.write(fd, buf, count);
\end_layout

\begin_layout Plain Layout

free(buf);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return ret;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
open.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

char path[MAXBUFSIZE];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint addr = thread.getSyscallArg(0);
\end_layout

\begin_layout Plain Layout

uint tgtFlags = thread.getSyscallArg(1);
\end_layout

\begin_layout Plain Layout

uint mode = thread.getSyscallArg(2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int strlen = thread.mem.readString(addr, MAXBUFSIZE, &path[0]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// translate open flags
\end_layout

\begin_layout Plain Layout

int hostFlags = 0;
\end_layout

\begin_layout Plain Layout

foreach(t; openFlagTable) {
\end_layout

\begin_layout Plain Layout

	if(tgtFlags & t.tgtFlag) {
\end_layout

\begin_layout Plain Layout

		tgtFlags &= ~t.tgtFlag;
\end_layout

\begin_layout Plain Layout

		hostFlags |= t.hostFlag;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// any target flags left?
\end_layout

\begin_layout Plain Layout

if(tgtFlags != 0)
\end_layout

\begin_layout Plain Layout

		logging.fatalf(LogCategory.SYSCALL,
\end_layout

\begin_layout Plain Layout

			"Syscall: open: cannot decode flags 0x%x", tgtFlags);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Adjust path for current working directory
\end_layout

\begin_layout Plain Layout

path = thread.process.fullPath(to!(string)(path));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// open the file
\end_layout

\begin_layout Plain Layout

int fd = open(path.ptr, hostFlags, mode);
\end_layout

\begin_layout Plain Layout

return fd;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
close.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

int fd = thread.getSyscallArg(0);
\end_layout

\begin_layout Plain Layout

int ret = close(fd);
\end_layout

\begin_layout Plain Layout

return ret;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
lseek.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

int fildes = thread.getSyscallArg(0);
\end_layout

\begin_layout Plain Layout

off_t offset = thread.getSyscallArg(1);
\end_layout

\begin_layout Plain Layout

int whence = thread.getSyscallArg(2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

off_t ret = lseek(fildes, offset, whence);
\end_layout

\begin_layout Plain Layout

return ret;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
getpid.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

return thread.process.pid;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
getuid.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

return thread.process.uid;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
brk.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint oldbrk, newbrk;
\end_layout

\begin_layout Plain Layout

uint oldbrk_rnd, newbrk_rnd;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

newbrk = thread.getSyscallArg(0);
\end_layout

\begin_layout Plain Layout

oldbrk = thread.process.brk;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(newbrk == 0) {
\end_layout

\begin_layout Plain Layout

	return thread.process.brk;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

newbrk_rnd = Rounding!(uint).roundUp(newbrk, MEM_PAGESIZE);
\end_layout

\begin_layout Plain Layout

oldbrk_rnd = Rounding!(uint).roundUp(oldbrk, MEM_PAGESIZE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(newbrk > oldbrk) {
\end_layout

\begin_layout Plain Layout

	thread.mem.map(oldbrk_rnd, newbrk_rnd - oldbrk_rnd,
\end_layout

\begin_layout Plain Layout

		MemoryAccessType.READ | MemoryAccessType.WRITE);
\end_layout

\begin_layout Plain Layout

} else if(newbrk < oldbrk) {
\end_layout

\begin_layout Plain Layout

	thread.mem.unmap(newbrk_rnd, oldbrk_rnd - newbrk_rnd);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

thread.process.brk = newbrk;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return thread.process.brk;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
getgid.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

return thread.process.gid;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
geteuid.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

return thread.process.euid;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
getegid.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

return thread.process.egid;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
fstat.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

int fd = thread.getSyscallArg(0);
\end_layout

\begin_layout Plain Layout

uint buf_addr = thread.getSyscallArg(1);
\end_layout

\begin_layout Plain Layout

stat_t* buf = cast(stat_t*)(malloc(stat_t.sizeof));
\end_layout

\begin_layout Plain Layout

int ret = fstat(fd, buf);
\end_layout

\begin_layout Plain Layout

if(ret >= 0) {
\end_layout

\begin_layout Plain Layout

	thread.mem.writeBlock(buf_addr, stat_t.sizeof, cast(ubyte*) buf);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

free(buf);
\end_layout

\begin_layout Plain Layout

return ret;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
uname.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

utsname un = {"Linux", "sim", "2.6", "Tue Apr 5 12:21:57 UTC 2005", "mips"};
\end_layout

\begin_layout Plain Layout

thread.mem.writeBlock(thread.getSyscallArg(0), un.sizeof, cast(ubyte*) &un);
\end_layout

\begin_layout Plain Layout

return 0;
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
_llseek.
 Its execution logic is shown as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

int fd = thread.getSyscallArg(0);
\end_layout

\begin_layout Plain Layout

uint offset_high = thread.getSyscallArg(1);
\end_layout

\begin_layout Plain Layout

uint offset_low = thread.getSyscallArg(2);
\end_layout

\begin_layout Plain Layout

uint result_addr = thread.getSyscallArg(3);
\end_layout

\begin_layout Plain Layout

int whence = thread.getSyscallArg(4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int ret;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(offset_high == 0) {
\end_layout

\begin_layout Plain Layout

	off_t lseek_ret = lseek(fd, offset_low, whence);
\end_layout

\begin_layout Plain Layout

	if(lseek_ret >= 0) {
\end_layout

\begin_layout Plain Layout

		ret = 0;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else {
\end_layout

\begin_layout Plain Layout

		ret = -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	ret = -1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return ret;
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Performance Simulation
\end_layout

\begin_layout Standard
Performance simulation encompasses the detailed simulation of out-of-order
 processor cores and multi-level memory hierarchies.
\end_layout

\begin_layout Section
Processor
\end_layout

\begin_layout Standard
Flexim supports the mix of SMT and CMP simulation.
 Some processor structures are shared among threads within a processor core,
 and others are private to each thread.
\end_layout

\begin_layout Subsection
Cycle-Accurate Modeling of Pipeline Structures
\end_layout

\begin_layout Standard
Flexim explicitly models the Reorder Buffer (
\family typewriter
ReorderBuffer
\family default
), the Issue Queue (
\family typewriter
IssueQueue
\family default
), the Load/Store Queue (
\family typewriter
LoadStoreQueue
\family default
), separate integer, floating-point and miscellaneous register files, register
 renaming, and the associated rename table.
\end_layout

\begin_layout Standard
The reorder buffer is modeled as a FIFO buffer.
 Its entries are pushed during instruction 
\family typewriter
dispatch()
\family default
 and are popped during instruction 
\family typewriter
commit()
\family default
.
 
\end_layout

\begin_layout Standard
The issue queue is modeled as an array of issue queue entries.
 Each issue queue entry (
\family typewriter
IssueQueueEntry
\family default
) can be in one of two states: either free(
\family typewriter
IssueQueueEntryState.FREE
\family default
) or already allocated(
\family typewriter
IssueQueueEntry.ALLOC
\family default
).
 Its entries are allocated at instruction 
\family typewriter
dispatch()
\family default
 and are released at 
\family typewriter
issue()
\family default
 and on branch mispredictions on 
\family typewriter
recoverReorderBuffer()
\family default
.
\end_layout

\begin_layout Standard
The integer, floating point and miscellaneous physical register files are
 modeled separately as 
\family typewriter
intRegFile
\family default
, 
\family typewriter
fpRegFile
\family default
 and 
\family typewriter
miscRegFile
\family default
, respectively.
 All of them contain an array of physical registers(
\family typewriter
PhysicalRegister
\family default
).
 Each of the physical registers can be in one of four states: 
\end_layout

\begin_layout Enumerate
the register is free (
\family typewriter
PhysicalRegisterState.FREE
\family default
),
\end_layout

\begin_layout Enumerate
the register has been allocated to an instruction but has not yet been written
 to (
\family typewriter
PhysicalRegisterState.ALLOC
\family default
),
\end_layout

\begin_layout Enumerate
the register is allocated to an instruction and the value has been written
 (
\family typewriter
PhysicalRegisterState.W
\family default
B),
\end_layout

\begin_layout Enumerate
the register is in the architectural state (
\family typewriter
PhysicalRegisterState.ARCH
\family default
).
\end_layout

\begin_layout Standard
Physical registers are allocated at the 
\family typewriter
dispatch()
\family default
 stage, and deallocated at 
\family typewriter
commit()
\family default
 and during branch mispredictions in 
\family typewriter
recoverReorderBuffer()
\family default
.
\end_layout

\begin_layout Standard
The integer, floating point and miscellaneous rename tables are modeled
 separately.
 They maintain the current mappings of each architectural register to a
 physical register.
\end_layout

\begin_layout Subsection
Details of the Processor model and Implementation
\end_layout

\begin_layout Standard
Threads within a core maintain separate program counters, but share the
 fetch unit and icache.
 Threads within a core share the available bandwidth in the front end including
 fetch, decode and rename.
 The time slice based fetch policy is implemented for the moment, more advanced
 policies such as icount is left for future work.
 Separate branch predictors are implemented per thread.
\end_layout

\begin_layout Standard
Each thread maintains its own rename table because it has its own set of
 architectural registers.
 After renaming, instructions from all threads are dispatched into the shared
 issue queue.
\end_layout

\begin_layout Standard
In the issue queue, instructions from all the threads participate in the
 instruction 
\family typewriter
wakeup()
\family default
 process and compete for the issue bandwidth in 
\family typewriter
selection()
\family default
.
 Instructions that are selected for issue continue to perform register file
 accesses.
 All the physical register files are shared among the threads.
 After register file accesses are done, instructions begin execution on
 the functional units, which are also shared among the threads.
\end_layout

\begin_layout Standard
Loads and stores access the shared dcache among the threads within a core.
 In order to maintain the correct orderings of memory accesses, the load/store
 queue (
\family typewriter
LoadStoreQueue
\family default
) is used.
 Separate load/store queue is maintained per thread, so that an unresolved
 address from one thread does not prevent loads in other threads from issuing.
\end_layout

\begin_layout Standard
After execution, instructions write back to the register files.
 Commitment (or retirement) is done in order for each thread out of the
 re-order buffers (
\family typewriter
ReorderBuffer
\family default
s).
 Separate reorder buffers are maintained per thread.
 
\end_layout

\begin_layout Section
Memory Hierarchy
\end_layout

\begin_layout Subsection
Internal Cache Structure and Cache Coherence
\end_layout

\begin_layout Standard
A two-level cache hierarchy is modeled for the moment.
 Cache coherence is enforced with the directory-based MESI protocol between
 the private level one caches owned by each core and the level two cache
 that shared among cores.
\end_layout

\begin_layout Standard
Besides the data, tag, and state, a cache block has a corresponding directory
 entry that contains the owner and sharers information of the block.
 The geometry parameters of each cache in the memory hierarchy are configured
 via XML files.
 The cache subblock granularity is currently not supported but planned for
 future work.
 The LRU cache replacement policy is implemented for the moment, the implementat
ions of more advanced policies are left as future work.
\end_layout

\begin_layout Standard
The details of the directory-based MESI protocols are described as below.
\end_layout

\begin_layout Enumerate

\family typewriter
findAndLock(addr, isBlocking, isRead, isRetry, onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint set, way, tag;
\end_layout

\begin_layout Plain Layout

MESIState state;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool hit = this.cache.findBlock(addr, set, way, tag, state, true);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint dumbTag;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(!hit) {
\end_layout

\begin_layout Plain Layout

  way = this.cache.replaceBlock(set);
\end_layout

\begin_layout Plain Layout

  this.cache.getBlock(set, way, dumbTag, state);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DirLock dirLock = this.cache.dir.dirLocks[set];
\end_layout

\begin_layout Plain Layout

if(!dirLock.lock()) {
\end_layout

\begin_layout Plain Layout

  if(isBlocking) {
\end_layout

\begin_layout Plain Layout

    onCompletedCallback(true, set, way, state, tag, dirLock);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else {
\end_layout

\begin_layout Plain Layout

    this.retry({this.findAndLock(addr, isBlocking, isRead, true, onCompletedCallba
ck);});
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

  this.cache[set][way].transientTag = tag;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  if(!hit && state != MESIState.INVALID) {
\end_layout

\begin_layout Plain Layout

    this.schedule(
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        this.evict(set, way, 
\end_layout

\begin_layout Plain Layout

          (bool hasError)
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            uint dumbTag;
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            if(!hasError) {
\end_layout

\begin_layout Plain Layout

              this.stat.evictions++;
\end_layout

\begin_layout Plain Layout

              this.cache.getBlock(set, way, dumbTag, state);
\end_layout

\begin_layout Plain Layout

              onCompletedCallback(false, set, way, state, tag, dirLock);
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            else {
\end_layout

\begin_layout Plain Layout

              this.cache.getBlock(set, way, dumbTag, state);
\end_layout

\begin_layout Plain Layout

              dirLock.unlock();
\end_layout

\begin_layout Plain Layout

              onCompletedCallback(true, set, way, state, tag, dirLock);
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          });
\end_layout

\begin_layout Plain Layout

      }, this.hitLatency);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else {      
\end_layout

\begin_layout Plain Layout

    this.schedule(
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        onCompletedCallback(false, set, way, state, tag, dirLock);
\end_layout

\begin_layout Plain Layout

      },
\end_layout

\begin_layout Plain Layout

    this.hitLatency);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
load(addr, isRetry, onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.findAndLock(addr, false, true, isRetry,
\end_layout

\begin_layout Plain Layout

  (bool hasError, uint set, uint way, MESIState state, uint tag, DirLock
 dirLock)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    if(!hasError) {
\end_layout

\begin_layout Plain Layout

      if(!isReadHit(state)) {
\end_layout

\begin_layout Plain Layout

        this.readRequest(this.next, tag,
\end_layout

\begin_layout Plain Layout

        (bool hasError, bool isShared) 
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          if(!hasError) {
\end_layout

\begin_layout Plain Layout

            this.cache.setBlock(set, way, tag, isShared ? MESIState.SHARED
\end_layout

\begin_layout Plain Layout

              : MESIState.EXCLUSIVE);
\end_layout

\begin_layout Plain Layout

            this.cache.accessBlock(set, way);
\end_layout

\begin_layout Plain Layout

            dirLock.unlock();               
\end_layout

\begin_layout Plain Layout

            onCompletedCallback();
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          else {
\end_layout

\begin_layout Plain Layout

            dirLock.unlock();
\end_layout

\begin_layout Plain Layout

            this.retry({this.load(addr, true, onCompletedCallback);});
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        });
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      else {
\end_layout

\begin_layout Plain Layout

        this.cache.accessBlock(set, way); 
\end_layout

\begin_layout Plain Layout

        dirLock.unlock();         
\end_layout

\begin_layout Plain Layout

        onCompletedCallback();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      this.retry({this.load(addr, true, onCompletedCallback);});
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  });
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
store(addr, isRetry, onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.findAndLock(addr, false, false, isRetry, 
\end_layout

\begin_layout Plain Layout

  (bool hasError, uint set, uint way, MESIState state, uint tag, DirLock
 dirLock)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    if(!hasError) {
\end_layout

\begin_layout Plain Layout

      if(!isWriteHit(state)) {
\end_layout

\begin_layout Plain Layout

        this.writeRequest(this.next, tag,
\end_layout

\begin_layout Plain Layout

          (bool hasError)
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            if(!hasError) {
\end_layout

\begin_layout Plain Layout

              this.cache.accessBlock(set, way);
\end_layout

\begin_layout Plain Layout

              this.cache.setBlock(set, way, tag, MESIState.MODIFIED);
\end_layout

\begin_layout Plain Layout

              dirLock.unlock();
\end_layout

\begin_layout Plain Layout

              onCompletedCallback();
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            else {
\end_layout

\begin_layout Plain Layout

              dirLock.unlock();
\end_layout

\begin_layout Plain Layout

              this.retry({this.store(addr, true, onCompletedCallback);});
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          });
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      else {
\end_layout

\begin_layout Plain Layout

        this.cache.accessBlock(set, way);
\end_layout

\begin_layout Plain Layout

        this.cache.setBlock(set, way, tag, MESIState.MODIFIED);
\end_layout

\begin_layout Plain Layout

        dirLock.unlock();
\end_layout

\begin_layout Plain Layout

        onCompletedCallback();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      this.retry({this.store(addr, true, onCompletedCallback);});
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  });
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
evict(set, way, onCompletedCallback)
\family default
.
 
\begin_inset Newline newline
\end_inset

Constant-latency (2) on-chip interconnect is assumed here.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint tag;
\end_layout

\begin_layout Plain Layout

MESIState state;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

this.cache.getBlock(set, way, tag, state);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint srcSet = set;
\end_layout

\begin_layout Plain Layout

uint srcWay = way;
\end_layout

\begin_layout Plain Layout

uint srcTag = tag;
\end_layout

\begin_layout Plain Layout

CoherentCacheNode target = this.next;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

this.invalidate(null, set, way, 
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    if(state == MESIState.INVALID) {
\end_layout

\begin_layout Plain Layout

      onCompletedCallback(false);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else if(state == MESIState.MODIFIED) {
\end_layout

\begin_layout Plain Layout

      this.schedule(
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          target.evictReceive(this, srcTag, true, 
\end_layout

\begin_layout Plain Layout

            (bool hasError)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              this.schedule(
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  this.evictReplyReceive(hasError, srcSet, srcWay, onCompletedCal
lback);
\end_layout

\begin_layout Plain Layout

                }, 2);
\end_layout

\begin_layout Plain Layout

            });
\end_layout

\begin_layout Plain Layout

        }, 2);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      this.schedule(
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          target.evictReceive(this, srcTag, false, 
\end_layout

\begin_layout Plain Layout

            (bool hasError)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

              this.schedule(
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  this.evictReplyReceive(hasError, srcSet, srcWay, onCompletedCal
lback);
\end_layout

\begin_layout Plain Layout

                }, 2);
\end_layout

\begin_layout Plain Layout

            });
\end_layout

\begin_layout Plain Layout

        }, 2);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  });
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset

evictReceive(source, addr, isWriteback, onReceivedReplyCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.findAndLock(addr, false, false, false, 
\end_layout

\begin_layout Plain Layout

      (bool hasError, uint set, uint way, MESIState state, uint tag, DirLock
 dirLock)
\end_layout

\begin_layout Plain Layout

      {       
\end_layout

\begin_layout Plain Layout

        if(!hasError) {
\end_layout

\begin_layout Plain Layout

          if(!isWriteback) {
\end_layout

\begin_layout Plain Layout

            this.evictProcess(source, set, way, dirLock, onReceiveReplyCallback);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          else {
\end_layout

\begin_layout Plain Layout

            this.invalidate(source, set, way, 
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                if(state == MESIState.SHARED) {
\end_layout

\begin_layout Plain Layout

                  this.writeRequest(this.next, tag,
\end_layout

\begin_layout Plain Layout

                    (bool hasError)
\end_layout

\begin_layout Plain Layout

                    {
\end_layout

\begin_layout Plain Layout

                      this.evictWritebackFinish(
\end_layout

\begin_layout Plain Layout

                        source, hasError, set, way, tag, dirLock, onReceiveReply
Callback);
\end_layout

\begin_layout Plain Layout

                    });
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

                else {
\end_layout

\begin_layout Plain Layout

                  this.evictWritebackFinish(
\end_layout

\begin_layout Plain Layout

                    source, false, set, way, tag, dirLock, onReceiveReplyCallbac
k);
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

              });
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else {
\end_layout

\begin_layout Plain Layout

          onReceiveReplyCallback(true);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      });
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset

evictWritebackFinish(source, hasError, set, way, tag, dirLock, onReceivedReplyCa
llback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

if(!hasError) {
\end_layout

\begin_layout Plain Layout

  this.cache.setBlock(set, way, tag, MESIState.MODIFIED);
\end_layout

\begin_layout Plain Layout

  this.cache.accessBlock(set, way);
\end_layout

\begin_layout Plain Layout

  this.evictProcess(source, set, way, dirLock, onReceiveReplyCallback);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

  dirLock.unlock();
\end_layout

\begin_layout Plain Layout

  onReceiveReplyCallback(true);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset

evictProcess(source, set, way, dirLock, onReceivedReplyCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

DirEntry dirEntry = this.cache.dir.dirEntries[set][way];
\end_layout

\begin_layout Plain Layout

dirEntry.unsetSharer(source);
\end_layout

\begin_layout Plain Layout

if(dirEntry.owner == source) {
\end_layout

\begin_layout Plain Layout

  dirEntry.owner = null;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

dirLock.unlock();
\end_layout

\begin_layout Plain Layout

onReceiveReplyCallback(false);
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset

evictReplyReceive(hasError, srcSet, srcWay, onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.schedule(
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    if(!hasError) {
\end_layout

\begin_layout Plain Layout

      this.cache.setBlock(srcSet, srcWay, 0, MESIState.INVALID);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    onCompletedCallback(hasError);
\end_layout

\begin_layout Plain Layout

  }, 2);
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
readRequest(target, addr, onCompletedCallback)
\family default
.
\begin_inset Newline newline
\end_inset

Cconstant-latency (2) on-chip interconnect is assumed here.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.schedule(
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    target.readRequestReceive(this, addr, onCompletedCallback);
\end_layout

\begin_layout Plain Layout

  }, 2);
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset

readRequestReceive(source, addr, onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.findAndLock(addr, this.next == source, true, false,
\end_layout

\begin_layout Plain Layout

  (bool hasError, uint set, uint way, MESIState state, uint tag, DirLock
 dirLock)
\end_layout

\begin_layout Plain Layout

  {       
\end_layout

\begin_layout Plain Layout

    if(!hasError) {
\end_layout

\begin_layout Plain Layout

      if(source.next == this) {
\end_layout

\begin_layout Plain Layout

        this.readRequestUpdown(source, set, way, tag, state, dirLock, onCompleted
Callback);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      else {
\end_layout

\begin_layout Plain Layout

        this.readRequestDownup(set, way, tag, dirLock, onCompletedCallback);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      this.schedule(
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          onCompletedCallback(true, false);
\end_layout

\begin_layout Plain Layout

        }, 2);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  });
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset


\family default
r
\family typewriter
eadRequestUpdown(source, set, way, tag, state, dirLock, onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint pending = 1;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

if(state != MESIState.INVALID) {
\end_layout

\begin_layout Plain Layout

  DirEntry dirEntry = this.cache.dir.dirEntries[set][way];
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  if(dirEntry.owner !is null && dirEntry.owner != source) {
\end_layout

\begin_layout Plain Layout

    pending++;
\end_layout

\begin_layout Plain Layout

    this.readRequest(dirEntry.owner, tag,
\end_layout

\begin_layout Plain Layout

      (bool hasError, bool isShared)
\end_layout

\begin_layout Plain Layout

      {
\end_layout

\begin_layout Plain Layout

        this.readRequestUpdownFinish(source, set, way, dirLock, pending,
 onCompletedCallback);
\end_layout

\begin_layout Plain Layout

      });
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  this.readRequestUpdownFinish(source, set, way, dirLock, pending, onCompletedCal
lback);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

  this.readRequest(this.next, tag,
\end_layout

\begin_layout Plain Layout

    (bool hasError, bool isShared)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      if(!hasError) {
\end_layout

\begin_layout Plain Layout

        this.cache.setBlock(set, way, tag, isShared ? MESIState.SHARED : MESIState.E
XCLUSIVE);
\end_layout

\begin_layout Plain Layout

        this.readRequestUpdownFinish(source, set, way, dirLock, pending,
 onCompletedCallback);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      else {
\end_layout

\begin_layout Plain Layout

        dirLock.unlock();
\end_layout

\begin_layout Plain Layout

        this.schedule(
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

            onCompletedCallback(true, false);
\end_layout

\begin_layout Plain Layout

          }, 2);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    });
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset

readRequestUpdownFinish(source, set, way, dirLock, ref pending, onCompletedCallb
ack)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

pending--;
\end_layout

\begin_layout Plain Layout

if(pending == 0) {
\end_layout

\begin_layout Plain Layout

  DirEntry dirEntry = this.cache.dir.dirEntries[set][way];
\end_layout

\begin_layout Plain Layout

  if(dirEntry.owner !is null && dirEntry.owner != source) {
\end_layout

\begin_layout Plain Layout

    dirEntry.owner = null;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  dirEntry.setSharer(source);
\end_layout

\begin_layout Plain Layout

  if(!dirEntry.isShared) {
\end_layout

\begin_layout Plain Layout

    dirEntry.owner = source;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  this.cache.accessBlock(set, way);
\end_layout

\begin_layout Plain Layout

  dirLock.unlock();
\end_layout

\begin_layout Plain Layout

  this.schedule(
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      onCompletedCallback(false, dirEntry.isShared);
\end_layout

\begin_layout Plain Layout

    }, 2);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset

readRequestDownup(set, way, tag, dirLock, onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint pending = 1;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

DirEntry dirEntry = this.cache.dir.dirEntries[set][way];
\end_layout

\begin_layout Plain Layout

if(dirEntry.owner !is null) {
\end_layout

\begin_layout Plain Layout

  pending++;
\end_layout

\begin_layout Plain Layout

  this.readRequest(dirEntry.owner, tag,
\end_layout

\begin_layout Plain Layout

    (bool hasError, bool isShared)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      this.readRequestDownUpFinish(set, way, tag, dirLock, pending, onCompletedCa
llback);
\end_layout

\begin_layout Plain Layout

    });
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

this.readRequestDownUpFinish(set, way, tag, dirLock, pending, onCompletedCallback
);
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset

readRequestDownUpFinish(set, way, tag, dirLock, ref pending, onCompletedCallback
)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

pending--;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(pending == 0) {
\end_layout

\begin_layout Plain Layout

  DirEntry dirEntry = this.cache.dir.dirEntries[set][way];
\end_layout

\begin_layout Plain Layout

  dirEntry.owner = null;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  this.cache.setBlock(set, way, tag, MESIState.SHARED);
\end_layout

\begin_layout Plain Layout

  this.cache.accessBlock(set, way);
\end_layout

\begin_layout Plain Layout

  dirLock.unlock();
\end_layout

\begin_layout Plain Layout

  this.schedule(
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      onCompletedCallback(false, false);
\end_layout

\begin_layout Plain Layout

    }, 2);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
writeRequest(target, addr, onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.schedule(
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    target.writeRequestReceive(this, addr, onCompletedCallback);
\end_layout

\begin_layout Plain Layout

  }, 2);
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset

writeRequestReceive(source, addr, onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

this.findAndLock(addr, this.next == source, false, false,
\end_layout

\begin_layout Plain Layout

  (bool hasError, uint set, uint way, MESIState state, uint tag, DirLock
 dirLock)
\end_layout

\begin_layout Plain Layout

  {       
\end_layout

\begin_layout Plain Layout

    if(!hasError) {
\end_layout

\begin_layout Plain Layout

      this.invalidate(source, set, way, 
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          if(source.next == this) {
\end_layout

\begin_layout Plain Layout

            if(state == MESIState.MODIFIED || state == MESIState.EXCLUSIVE)
 {
\end_layout

\begin_layout Plain Layout

              writeRequestUpdownFinish(
\end_layout

\begin_layout Plain Layout

                source, false, set, way, tag, state, dirLock, onCompletedCallbac
k);
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            else {
\end_layout

\begin_layout Plain Layout

              this.writeRequest(this.next, tag,
\end_layout

\begin_layout Plain Layout

                (bool hasError)
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                  writeRequestUpdownFinish(
\end_layout

\begin_layout Plain Layout

                    source, hasError, set, way, tag, state, dirLock, onCompleted
Callback);
\end_layout

\begin_layout Plain Layout

                });
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          else {
\end_layout

\begin_layout Plain Layout

            this.cache.setBlock(set, way, 0, MESIState.INVALID);
\end_layout

\begin_layout Plain Layout

            dirLock.unlock();
\end_layout

\begin_layout Plain Layout

            this.schedule(
\end_layout

\begin_layout Plain Layout

              {
\end_layout

\begin_layout Plain Layout

                onCompletedCallback(false);
\end_layout

\begin_layout Plain Layout

              }, 2);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        });
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      this.schedule(
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          onCompletedCallback(true);
\end_layout

\begin_layout Plain Layout

        }, 2);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  });
\end_layout

\end_inset


\family typewriter

\begin_inset Newline newline
\end_inset

writeRequestUpdownFinish(source, hasError, set, way, tag, state, dirLock,
 onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

if(!hasError) {
\end_layout

\begin_layout Plain Layout

  DirEntry dirEntry = this.cache.dir.dirEntries[set][way];
\end_layout

\begin_layout Plain Layout

  dirEntry.setSharer(source);
\end_layout

\begin_layout Plain Layout

  dirEntry.owner = source;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  this.cache.accessBlock(set, way);
\end_layout

\begin_layout Plain Layout

  if(state != MESIState.MODIFIED) {
\end_layout

\begin_layout Plain Layout

    this.cache.setBlock(set, way, tag, MESIState.EXCLUSIVE);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  dirLock.unlock();
\end_layout

\begin_layout Plain Layout

  this.schedule(
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      onCompletedCallback(false);
\end_layout

\begin_layout Plain Layout

    }, 2);                  
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

  dirLock.unlock();
\end_layout

\begin_layout Plain Layout

  this.schedule(
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      onCompletedCallback(true);
\end_layout

\begin_layout Plain Layout

    }, 2);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
invalidate(except, set, way, onCompletedCallback)
\family default
.
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

uint tag;
\end_layout

\begin_layout Plain Layout

    MESIState state;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    this.cache.getBlock(set, way, tag, state);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    uint pending = 1;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    DirEntry dirEntry = this.cache.dir.dirEntries[set][way];
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    CoherentCacheNode[] sharersToRemove;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    foreach(sharer; dirEntry.sharers) {
\end_layout

\begin_layout Plain Layout

      if(sharer != except) {
\end_layout

\begin_layout Plain Layout

        sharersToRemove ~= sharer;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    foreach(sharer; sharersToRemove) {
\end_layout

\begin_layout Plain Layout

      dirEntry.unsetSharer(sharer);
\end_layout

\begin_layout Plain Layout

      if(dirEntry.owner == sharer) {
\end_layout

\begin_layout Plain Layout

        dirEntry.owner = null;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      this.writeRequest(sharer, tag,
\end_layout

\begin_layout Plain Layout

        (bool hasError)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          pending--;
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

          if(pending == 0) {
\end_layout

\begin_layout Plain Layout

            onCompletedCallback();
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        });
\end_layout

\begin_layout Plain Layout

      pending++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    pending--;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if(pending == 0) {
\end_layout

\begin_layout Plain Layout

      onCompletedCallback();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
On-Chip Interconnect
\end_layout

\begin_layout Standard
Currently, constant-latency on-chip interconnect is modeled, the cycle-accurate
 simulation of on-chip interconnect is left as future work.
\end_layout

\begin_layout Subsection
Interface to External DRAM Simulators
\end_layout

\begin_layout Standard
Currently, constant-latency DRAM access is modeled, the cycle-accurate simulatio
n of on-chip interconnect is left as future work.
 The integration of DRAMSim with Flexim is planned.
\end_layout

\begin_layout Chapter
Supporting Infrastructure
\end_layout

\begin_layout Standard
There are various supporting modules aside the aforementioned main components
 to maintain the Flexim's reusability.
 
\end_layout

\begin_layout Section
Eventing and Callback Mechanisms
\end_layout

\begin_layout Standard
In flexim, cycle-accurate simulation is driven by event signals per cycle.
 Generally speaking, an event can be any piece of code that is scheduled
 to execute at the specified time.
 This piece of code can be represented as delegates in the D language.
 The delegate-based event queue (
\family typewriter
DelegateEventQueue
\family default
) is illustrated as below:
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

class DelegateEventQueue: EventProcessor {
\end_layout

\begin_layout Plain Layout

  this() {
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

  void processEvents() {
\end_layout

\begin_layout Plain Layout

    if(currentCycle in this.events) {
\end_layout

\begin_layout Plain Layout

      foreach(event; this.events[currentCycle]) {
\end_layout

\begin_layout Plain Layout

        event();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      this.events.remove(currentCycle);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  void schedule(void delegate() event, ulong delay = 0) {
\end_layout

\begin_layout Plain Layout

    this.events[currentCycle + delay] ~= event;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  void delegate()[][ulong] events;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The delegate-based callback mechanism is used extensively in the implementation
 of the MESI cache coherence protocol.
 This way, the code is clean and readable.
\end_layout

\begin_layout Section
Categorized Logging Mechanism
\end_layout

\begin_layout Standard
The logging component supports configurable logging functionalities that
 can facilitate development and even be useful after release.
 The code skeleton of the Logger class is shown as below:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

class Logger {
\end_layout

\begin_layout Plain Layout

  static this() {
\end_layout

\begin_layout Plain Layout

    singleInstance = new Logger();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  bool enabled(LogCategory category) {
\end_layout

\begin_layout Plain Layout

    return category in this.logSwitches && this.logSwitches[category];
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  string message(string caption, string text) {
\end_layout

\begin_layout Plain Layout

    return format("[%d] 
\backslash
t%s%s", currentCycle, 
\end_layout

\begin_layout Plain Layout

      caption.endsWith("info") ? "" : "[" ~ caption ~ "] ", text);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  void infof(LogCategory, T...)(LogCategory category, T args) {
\end_layout

\begin_layout Plain Layout

    debug {
\end_layout

\begin_layout Plain Layout

      this.info(category, format(args));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  void info(LogCategory category, string text) {
\end_layout

\begin_layout Plain Layout

    debug {
\end_layout

\begin_layout Plain Layout

      if(this.enabled(category)) {
\end_layout

\begin_layout Plain Layout

        stdout.writeln(this.message(category ~ "|" ~ "info", text));
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  bool[LogCategory] logSwitches;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  static Logger singleInstance;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
XML-Based Input/Output for Configurations and Statistics
\end_layout

\begin_layout Standard
Extensible Markup Language (XML) is a standard and pervasive mechanism for
 representing structural data in a machine-readable and human-friendly way.
 Here XML-based configuration specification and statistics output are provided.
 For example, the following code shows how to serialize and deserialize
 a cache configuration using the provided XML I/O support:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

class CacheConfigXMLSerializer: XMLSerializer!(CacheConfig) { 
\end_layout

\begin_layout Plain Layout

  override XMLConfig save(CacheConfig cacheConfig) {
\end_layout

\begin_layout Plain Layout

    XMLConfig xmlConfig = new XMLConfig("CacheConfig");
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    xmlConfig["name"] = cacheConfig.name;
\end_layout

\begin_layout Plain Layout

    xmlConfig["level"] = to!(string)(cacheConfig.level);
\end_layout

\begin_layout Plain Layout

    xmlConfig["numSets"] = to!(string)(cacheConfig.numSets);
\end_layout

\begin_layout Plain Layout

    xmlConfig["assoc"] = to!(string)(cacheConfig.assoc);
\end_layout

\begin_layout Plain Layout

    xmlConfig["blockSize"] = to!(string)(cacheConfig.blockSize);
\end_layout

\begin_layout Plain Layout

    xmlConfig["hitLatency"] = to!(string)(cacheConfig.hitLatency);
\end_layout

\begin_layout Plain Layout

    xmlConfig["missLatency"] = to!(string)(cacheConfig.missLatency);
\end_layout

\begin_layout Plain Layout

    xmlConfig["policy"] = to!(string)(cacheConfig.policy);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    return xmlConfig;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  override CacheConfig load(XMLConfig xmlConfig) {
\end_layout

\begin_layout Plain Layout

    string name = xmlConfig["name"];
\end_layout

\begin_layout Plain Layout

    uint level = to!(uint)(xmlConfig["level"]);
\end_layout

\begin_layout Plain Layout

    uint numSets = to!(uint)(xmlConfig["numSets"]);
\end_layout

\begin_layout Plain Layout

    uint assoc = to!(uint)(xmlConfig["assoc"]);
\end_layout

\begin_layout Plain Layout

    uint blockSize = to!(uint)(xmlConfig["blockSize"]);
\end_layout

\begin_layout Plain Layout

    uint hitLatency = to!(uint)(xmlConfig["hitLatency"]);
\end_layout

\begin_layout Plain Layout

    uint missLatency = to!(uint)(xmlConfig["missLatency"]);
\end_layout

\begin_layout Plain Layout

    CacheReplacementPolicy policy = cast(CacheReplacementPolicy) (
\end_layout

\begin_layout Plain Layout

      xmlConfig["policy"]);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    CacheConfig cacheConfig = new CacheConfig(
\end_layout

\begin_layout Plain Layout

      name, level, numSets, assoc, blockSize, hitLatency, missLatency, policy);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    return cacheConfig;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  static this() {
\end_layout

\begin_layout Plain Layout

    singleInstance = new CacheConfigXMLSerializer();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  static CacheConfigXMLSerializer singleInstance;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Plotting and Table Generation for Experiments
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Chapter
Evaluation, Limitations and Future Work
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Section
Benchmark Evaluation
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Subsection
Criteria
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Subsection
Results
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Section
Comparison to Other Simulators
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Subsection
Results
\end_layout

\begin_layout Standard

\size footnotesize
\color red
(Pre-release, Documentation-in-Progress)
\end_layout

\begin_layout Section
Limitations and Future Work
\end_layout

\begin_layout Standard
Here are some of the limitations of Flexim.
 This list is not intended to be comprehensive, but rather aims to provide
 the user with an initial understanding of the capabilities of the Flexim
 simulation environment.
 These capabilities are subject to change in future releases.
\end_layout

\begin_layout Itemize
Only statically compiled MIPS32 binaries are suported by Flexim.
 Multi-ISA support and loading support of dynamically compiled programs
 are remained as future work.
\end_layout

\begin_layout Itemize
The explicit modeling of Miss Status Holding Registers (MSHRs) is not implemente
d and left as future work.
\end_layout

\begin_layout Itemize
Cycle-accurate on-chip interconnect and dram controller modeling is not
 implemented and left as future work.
\end_layout

\end_body
\end_document
