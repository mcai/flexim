#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass paper
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing onehalf
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Flexim: Streamlined Cycle-Accurate Simulation of Multicore Processors
\end_layout

\begin_layout Author
Min Cai, Zhimin Gu
\end_layout

\begin_layout Institution
Beijing Institute of Technology, Beijing 100081, P.R.China
\end_layout

\begin_layout Abstract
Good cycle-accurate simulators are critical for conducting successful multicore
 processor architecture research nowadays.
 However, most of the existing simulators are written in C or C++ for speed
 considerations and the modeled computer structures and functionalities
 are too complicated to be implemented in a clear yet efficient way.
 The resulting unreadable code makes the simulator hard to use and extend.
 As a niche market, other not-so-realistic simulators are mostly used for
 educational and visualization purposes that they are written in traditional
 object-oriented languages such as Java or C#, which omit many machine details
 that are necessary for architectural study.
 Oftentimes, users need to use a dozen of auxiliary tools and advanced scripting
 to automate the simulation process and do the housekeeping work such as
 statistics collection and reporting.
 There is a permanent need of balancing speed and elegance while simulating
 multicore architectures.
 
\end_layout

\begin_layout Abstract
In this paper, we present Flexim, a streamlined cycle-accurate multicore
 architectural simulation platform, which consists of the simulator core
 and the GUI based Integrated Simulation Environment (ISE) .
 Within the core, Flexim remodels the core functionalities of the classic
 SimpleScalar simulator and extends it to enable configurable timing simulation
 of out-of-order cores and multi-level cache hierarchies of multicore processors.
 It exploits interface-based object orientation and cycle-accurate callback-base
d eventing to improve the modularity and extensibility of the simulator
 core.
 The GUI-based ISE uses componentization and visualization techniques to
 streamline the typical simulation life-cycle of architectural planning,
 simulator configuration and statistics collection & reporting.
 Various static and dynamic views are provided to show the user a consistent
 yet changing view of the simulation process and the multicore architecture
 under simulation.
 The pervasive use of XML files provide human readable and machine-friendly
 configuration and statistics representation that bridges the simulator
 core and the ISE.
 Simulations of a few popular benchmark suites such as Olden and CPU2006
 are shown for illustrative purposes.
\end_layout

\begin_layout Keywords
Cycle-accurate simulator, multicore processor architecture, integrated simulatio
n environment
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Decades of technology advances and architectural innovation in microprocessors
 has led to complex multicore designs that combine multiple physical processing
 cores on a single chip.
 Such design consists of three major parts: the microprocessor core, the
 cache hierarchy and the interconnection network.
 The design and implementation of the microprocessor core and the cache
 hierarchy are highly coupled and interrelated.
 And the interconnection network provides a fast and efficient transmission
 media that glues together all the computing and storage resources on the
 chip.
\end_layout

\begin_layout Standard
In order to evaluate the impact on the overall performance of any design
 improvement on any of the three major parts, many cycle-accurate simulators
 are created to model the three major parts and their integration in a system
 working as a whole.
 Yet many of architectural simulators come and go with a short life-cycle,
 because they are unable to satisfy the stringent yet fluid needs of innovating
 new computer architectures.
\end_layout

\begin_layout Standard
Most of the existing simulators are written in C or C++ for speed considerations
 and the modeled computer structures and functionalities are too complicated
 to be implemented in a clear yet efficient way.
 The resulting unreadable code makes the simulator hard to use and extend.
 As a niche market, other not-so-realistic simulators are mostly used for
 educational and visualization purposes that they are written in traditional
 object-oriented languages such as Java or C#, which omit many machine details
 that are necessary for architectural study.
 There is a permanent need of balancing speed and elegance while simulating
 multicore architectures.
 
\end_layout

\begin_layout Standard
In this paper, we present Flexim, a streamlined cycle-accurate multicore
 architectural simulator, which consists of the simulator core and the GUI
 based Integrated Simulation Environment (ISE) .
 Within the core, Flexim remodels the core functionalities of the classic
 SimpleScalar simulator and extends it to enable configurable timing simulation
 of out-of-order cores and multi-level cache hierarchies of multicore processors.
 It exploits interface-based hierarchical modularity and cycle-accurate
 callback-based eventing to improve the modularity and extensibility of
 the simulator core.
 For the GUI-based ISE, Flexim uses XML files to ease the configuration
 of the simulator, and utilizes graph visualization to provide static and
 dynamic views of the multicore architecture under simulation.
 Simulations of a few popular benchmark suites such as Olden and CPU2006
 are shown for illustrative purposes.
\end_layout

\begin_layout Standard
The main contribution of this paper is highlighted as below:
\end_layout

\begin_layout Enumerate
To our knowledge, the proposed Flexim simulator is the first object-oriented
 architectural simulator written in the modern systems programming language
 D in the world.
 Having good software engineering practice in mind, a few D language features
 are utilized extensively to improve the simulator's code readability, maintaina
bility and run-time reconfigurability.
\end_layout

\begin_layout Enumerate
Cycle-accurate callback-based eventing is used for modeling both the out-of-orde
r pipeline model and multi-level cache hierarchy, clarifying the interaction
 between the execution-driven simulator and the timing simulation modules.
\end_layout

\begin_layout Enumerate
GUI-based integrated simulation environment is introduced to streamline
 the learning curve of architectural simulators.
 XML files and graph-based visualization are used to implement a reconfigurable
 yet user-friendly architectural simulator.
\end_layout

\begin_layout Standard
The rest of this paper is structured as follows.
 Section 2 provides an overview of existing processor simulators and their
 comparative features.
 Section 3 describes Flexim with significant development details.
 Section 4 discusses the provisioning of modular and event-driven simulation
 of out-of-order cores and cache hierarchies.
 Section 5 elaborates on the design and implementation details of the integrated
 simulation environment.
 Simulation results from some popular benchmark suites are shown in section
 5.
 Finally, section 6 concludes the paper.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
Multiple simulation environments, aimed for computer architecture research,
 have been developed.
 The most widely used simulator during the recent years has been SimpleScalar
 
\begin_inset CommandInset citation
LatexCommand cite
key "Austin2002"

\end_inset

, which serves as the basis of some Flexim functional simulation modules.
 It models an out-of-order superscalar processor.
 Lots of extensions have been applied to SimpleScalar to model certain aspects
 of superscalar processors in a more accurate manner.
 For example, the HotLeakage simulator [] quantifies leakage energy consumption.
 However, SimpleScalar is quite difficult to extend to model new parallel
 microarchitectures without significantly changing its structure.
 In spite of this fact, three SimpleScalar extensions to support multithreading
 and/or multicore have been implemented in the SSMT [], M-Sim [] and Multi2Sim
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ubal2007multi2sim"

\end_inset

 simulators.
 While SSMT and M-Sim are useful to implement designs based on simultaneous
 multithreaded processors, Multi2sim provides detailed simulation of multicore
 multithreaded processors in x86 ISA.
\end_layout

\begin_layout Standard
SimpleScalar is an 
\shape italic
application-only
\shape default
 tool, that is, a simulator that executes directly an application and simulate
 its execution by providing a simplistic and fictitious underlying operation
 system via system call emulation.
 Such tools are characterized by not supporting the architecture-specific
 privileged instruction set, since applications are not allowed to execute
 it.
 However, application-only simulators have the advantage of isolating the
 application execution, so statistics are not affected by the simulation
 of a real operating system.
 The proposed simulator Flexim can be classified as an application-only
 simulator, too.
\end_layout

\begin_layout Standard
In contrast to the application-only simulators, a set of so-called 
\shape italic
full-system
\shape default
 simulators are available.
 In such environments, an unmodified operating system is booted over the
 simulator and applications run at the same time over the simulated operating
 system.
 Thus, the entire instruction set and the interfacing with functional models
 of many I/O devices need be implemented, but no emulation of system calls
 is required.
 Although this model provides higher simulation power, it involves a huge
 computational overhead and sometimes unnecessary simulation accuracy.
\end_layout

\begin_layout Standard
Simics 
\begin_inset CommandInset citation
LatexCommand cite
key "Magnusson2002"

\end_inset

 is an example of full-system functional simulator which is commonly used
 for multi-processor systems simulation although it is not freely available.
 Simics provides a powerful set of APIs that a variety of its extensions
 have been created for specific purposes in this research area.
 GEMS 
\begin_inset CommandInset citation
LatexCommand cite
key "Martin2005"

\end_inset

 is a popular Simics extension which provides timing simulation capabilities
 to model the architectural details of multiprocessors such as instruction
 fetch and decode, branch prediction, dynamic instruction scheduling and
 execution and speculative memory hierarchy access.
 GEMS also provides a specification language for defining cache coherence
 protocols.
 However, any simulator based on Simics, like GEMS, must boot and run an
 operating system, so high computational load is increased with each extension.
\end_layout

\begin_layout Standard
GEMS provides an important feature of processor simulators which is called
 
\shape italic
timing first simulation
\shape default
.
 In this scheme, for example, one timing simulation module traces the state
 of the processor pipeline while instructions traverse it, and another timing
 simulation module traces the state of the caches while requests traverses
 them.
 In the pipeline case, the functional module is only called to actually
 execute the instructions when they reach the commit stage, so the correct
 execution paths are always guaranteed by a previously developed robust
 simulator.
 The timing-first approach confers efficiency, robustness, and the possibility
 of creating a series of simulators gradually with more and more details
 and accuracy.
\end_layout

\begin_layout Standard
And the last well-known simulator that we mention here is M5 
\begin_inset CommandInset citation
LatexCommand cite
key "Binkert2006"

\end_inset

 .
 This simulator provides support for simple one-CPU functional CPU, out-of-order
 SMT-capable CPUs, multiprocessors and coherence caches.
 It integrates the full-system and application-only simulation modes.
\end_layout

\begin_layout Standard
As summary, Flexim has been developed integrating the most significant character
istics of important simulators, such as separation of functional and timing
 simulation, SMT and multiprocessor support and directory-based cache coherence.
\end_layout

\begin_layout Section
Basic Simulator Description
\end_layout

\begin_layout Standard
This section details the main implementation issues that lead to a final
 simulation environment, and exposes some tips to bring it into use with
 workloads that created from the combination of some popular benchmarks.
 These aspects are addressed by showing some usage scenarios, describing
 briefly the process of loading an ELF MIPS32 executable into a running
 process's virtual memory, and analyzing the simulator structure that divided
 by functional and detailed simulation.
\end_layout

\begin_layout Subsection
Simulator and Workloads Compilation
\end_layout

\begin_layout Standard
Flexim is written in the systems programming language D, so in order to
 compile Flexim code, you need to obtain the latest DMD 2.0 compiler from
 DigitalMars' website
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://www.digitalmars.com/d/download.html"

\end_inset

.
\end_layout

\end_inset

, and follows the provided instructions to install the compiler.
 The latest Flexim code can be downloaded at the project's website on Github
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://github.com/mcai/flexim/"

\end_inset

.
\end_layout

\end_inset

, as a compressed tar file, and has been tested on x86 and x64 machine architect
ures, with Linux OS.
 The following commands should be entered in a command terminal to compile
 it:
\end_layout

\begin_layout Standard

\family typewriter
tar xzf mcai-flexim-<checkout_version>.tar.gz
\end_layout

\begin_layout Standard

\family typewriter
cd mcai-flexim-<checkout_version>
\end_layout

\begin_layout Standard

\family typewriter
make
\end_layout

\begin_layout Standard
Flexim simulates final executable files, statically compiled for the MIPS32
 Little Endian architecture, so a cross-compiler is also required to compile
 your own program sources.
 There is a workable MIPS32 cross-compiler (cross-compiler-mipsel.tar.bz2)
 available on the Flexim's project website on Github
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://github.com/mcai/flexim/downloads/"

\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Dynamic linking is not supported, so executables must be compiled statically.
 A command line to compile a program composed by a single source file named
 program.c could be:
\end_layout

\begin_layout Standard

\family typewriter
mipsel-linux-gcc program.c -Wall -o program.mipsel32 -static
\end_layout

\begin_layout Standard
Executables usually have an approximate minimum size of 4MB, since all libraries
 are linked with it.
 For programs that use the math library or 
\family typewriter
pthread
\family default
 library, simply include 
\family typewriter
-lm
\family default
 or 
\family typewriter
-lpthread
\family default
 into the command line.
 Sample Makefiles for a few benchmarks are provided within the Flexim distributi
on.
\end_layout

\begin_layout Subsection
Functional Simulation and Detailed Simulation
\end_layout

\begin_layout Standard
The relationship between Flexim modules used for functional simulation and
 detailed simulation are illustrated in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:functional_vs_timing_sinmulation"

\end_inset

.
 The simulated workload and the system call emulation module provides the
 input instruction stream to be executed by the functional simulation module.
 And the functional simulation module feeds the execution flow information
 to the timing simulation module, and the timing simulation module provides
 feedback containing the requested timing information of instructions and
 memory requests.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/itecgo/Flexim/code/flexim/doc/simulated_component_interaction.pdf
	scale 63
	BoundingBox 75bp 210bp 725bp 450bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The relationship between workload, functional simulation and timing simulation.
\begin_inset CommandInset label
LatexCommand label
name "fig:functional_vs_timing_sinmulation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Functional Simulation
\end_layout

\begin_layout Standard
The functional simulation engine provides an interface to the rest of the
 simulator and implements functionalities such as creating or destroying
 software contexts, performing program loading, enumerating existing contexts,
 consulting their status, executing a new instruction.
\end_layout

\begin_layout Standard
The supported machine architecture is MIPS32 Little Endian.
 The main reasons for choosing the MIPS32 instruction set 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The MIPS32 instructions that are not used by the 
\family typewriter
gcc
\family default
 compiler are excluded from this implementation.
 Also instructions belonging to the privileged instruction set are not implement
ed.
\end_layout

\end_inset

 is the availability of an easy-to-understand architecture specification
 and the simple and systematic identification of machine instructions, motivated
 by a fixed instruction size and an instruction decomposition in instruction
 fields.
\end_layout

\begin_layout Standard
As a remark, the difference between the terms 
\family typewriter
context
\family default
 and 
\family typewriter
thread
\family default
 should be clarified.
 A 
\family typewriter
context
\family default
 is used in this work as a software entity, defined by the status of a virtual
 memory image and a logical file.
 In contrast, a 
\family typewriter
thread
\family default
 is used as a processor hardware entity, and can comprise a physical register
 file, a set of physical memory pages, a set of entries in the pipeline
 queues, etc.
 The simulator kernel only handles contexts, and does not know of architecture
 specific hardware, such as threads or cores.
 
\color red
[work should be done here]
\end_layout

\begin_layout Standard
Since Flexim simulates target applications, the underlying operating system
 services (such as program loading or system calls) are performed internally
 by the simulator.
 This is done by modifying the memory and logical registers status so that
 the application sees the result of the system call.
\end_layout

\begin_layout Subsubsection
Detailed Simulation
\end_layout

\begin_layout Standard
The Flexim detailed simulator uses the functional engine to perform an execution
-driven simulation: during each cycle, a sequence of calls update the existing
 contexts states.
 The detailed simulator analyzes the nature of the recently executed machine
 instructions and accounts the operation latencies incurred by hardware
 structures.
\end_layout

\begin_layout Standard
The branch predictor implementation is based on Marss86.
 Caches and TLBs are implemented, including the MESI cache coherence protocol.
 Current interconnection network is a constant-latency simplification.
 MMU (Memory Management Unit) is provided to map virtual address spaces
 of contexts into a single physical memory space.
 Physical addresses are then used to index caches or branch predictors,
 without including the context identifier across modules.
\end_layout

\begin_layout Standard
The out-of-order pipeline modeling module defines and manages a few processor
 structures such as decode buffers, reorder buffers, load/store queues and
 functional units.
 And the pipeline stages defines the behavior of the configured multithreaded
 multicore processor.
\end_layout

\begin_layout Standard
Configuration specification and statistics output for the simulated entities
 such as cores, threads and caches are implemented via XML-formatted I/O,
 which is easy to use and machine-readable.
\end_layout

\begin_layout Section
Object-Oriented Based Event-Driven Cycle-Accurate Simulation of Multicore
 Architectures
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Subsubsection
Simulated Multicore Architecture
\end_layout

\begin_layout Standard
As shown in Fig.
\begin_inset CommandInset label
LatexCommand label
name "fig:Simulated-Multicore-Architecture"

\end_inset

, our simulated baseline multicore system design consists of two OoO cores,
 a two-level cache hierarchy and a fixed-latency point-to-point on-chip
 interconnect.
 Both cache levels are lockup-free and store the state of outstanding requests
 via callbacks.
 Each of the private first-level split caches are currently implemented
 as write-back, but should be write-through with a coalescing store buffer.
 The shared second-level cache is write-back and maintains inclusion with
 respect to the first-level cache.
 Each cache maintains a on-chip directory.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/itecgo/Flexim/code/flexim/doc/simulated_multicore_arch.pdf
	scale 63
	BoundingBox 28bp 242bp 570bp 580bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Overview of the Simulated Multicore System
\begin_inset CommandInset label
LatexCommand label
name "fig:fig:Simulated-Multicore-Architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Object Orientation and Callback-Based Cycle-Accurate Eventing
\end_layout

\begin_layout Subsection
Simulating Out-of-Order Cores
\end_layout

\begin_layout Subsubsection
Behavioral Modeling
\end_layout

\begin_layout Standard
Flexim supports the mix of SMT and CMP simulation.
 As shown in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pipeline_arch"

\end_inset

, the simulated out-of-order pipeline is divided into five stages: 
\family typewriter
fetch
\family default
, 
\family typewriter
decode/rename/dispatch
\family default
, 
\family typewriter
issue
\family default
, 
\family typewriter
execute
\family default
, and 
\family typewriter
commit
\family default
.
 The buffers between pipeline stages such as decode buffer (
\family typewriter
DecodeBuffer
\family default
), reorder buffer (
\family typewriter
ReorderBuffer
\family default
) and load/store queue (
\family typewriter
LoadStoreQueue
\family default
) are explicitly modeled.
\end_layout

\begin_layout Standard
A set of parameters are provided to specify how the pipeline stages are
 organized in a multithreaded design.
 Stages can be shared among threads or private per thread.
 Moreover, when a stage is shared, there must be an algorithm which schedules
 a thread each cycle on the stage.
 The modeled pipe stages are described briefly as below.
\end_layout

\begin_layout Paragraph
The Five Pipeline Stages.
\end_layout

\begin_layout Enumerate
Fetch.
 The 
\family typewriter
fetch
\family default
 stage takes instructions from the L1 instruction cache and places them
 into a decode buffer.
 
\end_layout

\begin_layout Enumerate
Decode, Rename & Dispatch.
 The 
\family typewriter
decode/rename/dispatch
\family default
 stage takes instruction from a decode buffer, decodes them, maps architectural
 register dependencies (
\family typewriter
RegisterDependency
\family default
) into allocated physical registers (
\family typewriter
PhysicalRegister
\family default
), assigns them a reorder buffer entry and places them into a ready queue
 (
\family typewriter
ReadyQueue
\family default
) or a waiting queue (
\family typewriter
WaitingQueue
\family default
) depending on whether their input operands are available or not.
\end_layout

\begin_layout Enumerate
Issue.
 Then, the 
\family typewriter
issue
\family default
 stage consumes the instructions from the ready queue and sends them to
 the corresponding functional units, and the data cache is accessed for
 memory instructions.
\end_layout

\begin_layout Enumerate
Execute.
 During the 
\family typewriter
execute
\family default
 stage, the functional units operate and write their results into the register
 file.
 This stage is implicitly modeled in Flexim.
\end_layout

\begin_layout Enumerate
Commit.
 Finally, the 
\family typewriter
commit
\family default
 stage retires instructions from the reorder buffer in the program order.
 
\end_layout

\begin_layout Standard
This architecture is analogous to the one modeled by the SimpleScalar tool
 set, but uses a decode buffer, a reorder buffer and a few physical register
 files to replace an integrated 
\family typewriter
Register Update Unit
\family default
 (RUU).
 In the current implementation, the functional unit pool, physical register
 files, ready queue, waiting queue are shared among threads in a processor
 core; and the decode buffer, reorder buffer, and load/store queue are private
 per thread.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/itecgo/Flexim/code/flexim/doc/processor.eps
	display false
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Overview of the Simulated Out-of-Order Processor Pipeline
\begin_inset CommandInset label
LatexCommand label
name "fig:pipeline_arch"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Structural Modeling
\end_layout

\begin_layout Paragraph
Physical Register File and Rename Table.
\end_layout

\begin_layout Standard
The integer, floating point and miscellaneous physical register files (
\family typewriter
PhysicalRegisterFile
\family default
) are modeled separately.
 All of them contain an array of physical registers (
\family typewriter
PhysicalRegister
\family default
s).
 Each of the physical registers can be in one of four states:
\end_layout

\begin_layout Enumerate
the physical register is free (
\family typewriter
PhysicalRegisterState.FREE
\family default
);
\end_layout

\begin_layout Enumerate
the physical register has been allocated to an instruction but has not been
 written to (
\family typewriter
PhysicalRegisterState.ALLOC
\family default
);
\end_layout

\begin_layout Enumerate
the physical register has been allocated to an instruction and the value
 has been written (
\family typewriter
PhysicalRegisterState.WB
\family default
);
\end_layout

\begin_layout Enumerate
the physical register is in the architectural state (
\family typewriter
PhysicalRegisterState.ARCH
\family default
).
\end_layout

\begin_layout Standard
Physical registers are allocated during instruction dispatch, and deallocated
 during instruction commit and reorder buffer recovery when branch misprediction
 is detected.
\end_layout

\begin_layout Standard
The integer, floating point and miscellaneous rename tables are modeled
 separately.
 They maintain the current mappings of each architectural register to a
 physical register.
 Each thread maintains its own rename table because it has its own set of
 architectural registers.
\end_layout

\begin_layout Paragraph
Functional Unit Pool.
\end_layout

\begin_layout Standard
The functional unit pool (
\family typewriter
FunctionalUnitPool
\family default
) is a collection of various categories of functional units (
\family typewriter
FunctionalUnit
\family default
s).
 Each category has a few number of functional units (specified by 
\family typewriter
quantity
\family default
), and has a fixed issue latency (
\family typewriter
issueLat
\family default
) and execution latency (
\family typewriter
execLat
\family default
).
 Each of the functional units can be one of two states (indicated by 
\family typewriter
busy
\family default
):
\end_layout

\begin_layout Enumerate
the functional unit is free (
\family typewriter
busy
\family default
 is set to false);
\end_layout

\begin_layout Enumerate
the functional unit has been allocated to execute an instruction (
\family typewriter
busy
\family default
 is set to true).
\end_layout

\begin_layout Standard
Upon instruction issue, the functional unit pool is queried to find a free
 functional unit of the specified functional unit category (
\family typewriter
FunctionalUnitType
\family default
) for a ready instruction from the ready queue.
 If a free functional unit is found, the instruction is issued.
 Otherwise, the instruction is pushed back into the ready queue.
\end_layout

\begin_layout Paragraph
Branch Predictors.
\end_layout

\begin_layout Standard
Branch predictors provides the prediction of branch direction and targets.
 The branch predictors in Flexim.
 are modeled after Marss86.
 Three kinds of branch predictors (interface 
\family typewriter
Bpred
\family default
) are implemented: the bimod predictor (
\family typewriter
BimodBpredDir
\family default
), the two level predictor (
\family typewriter
TwoLevelBpredDir
\family default
) and the combined predictor (
\family typewriter
TwoLevelBpredDir
\family default
).
 Separate branch predictors are implemented per thread.
\end_layout

\begin_layout Paragraph
Decode Buffer.
\end_layout

\begin_layout Standard
The decode buffer is used as a FIFO queue between the instruction fetch
 stage and the decode/rename/dispatch stage.
\end_layout

\begin_layout Paragraph
Reorder Buffers.
\end_layout

\begin_layout Standard
In order to maintain the correct ordering of the committed instructions,
 the reorder buffer is explicitly modeled as a FIFO (First-In-First-Out)
 buffer.
 Its entries (
\family typewriter
ReorderBufferEntry
\family default
) are pushed during instruction dispatch and are popped in the program order
 during instruction commit.
\end_layout

\begin_layout Paragraph
load/store queues.
\end_layout

\begin_layout Standard
Loads and store access the L1 data cache shared among threads within a core.
 In order to keep track of pending memory accesses, the load/store queue
 (
\family typewriter
LoadStoreQueue
\family default
) is used.
 Separate load/store queue is maintained per thread, so that an unresolved
 address from one thread does not prevent loads in other threads from issuing.
\end_layout

\begin_layout Subsection
Simulating Multi-Level Cache Hierarchies
\end_layout

\begin_layout Standard
A two-level cache hierarchy is modeled for the moment.
 Cache coherence is enforced with the directory-based MESI protocol between
 the private level one caches owned by each core and the level two cache
 that shared among cores.
\end_layout

\begin_layout Standard
Currently, constant-latency on-chip interconnect is modeled, the cycle-accurate
 simulation of on-chip interconnect and DRAM access is left as future work.
 The integration of DRAMSim with Flexim is planned.
\end_layout

\begin_layout Subsubsection
Structural Modeling
\end_layout

\begin_layout Standard
Besides the data, tag, and state, a cache block has a corresponding directory
 entry that contains the owner and sharers information of the block.
 The geometry parameters of each cache in the memory hierarchy are configured
 via XML files.
 The cache subblock granularity is currently not supported but planned for
 future work.
 The LRU cache replacement policy is implemented for the moment, the implementat
ions of more advanced policies are left as future work.
\end_layout

\begin_layout Paragraph
Cache.
 
\end_layout

\begin_layout Standard
Each cache (
\family typewriter
Cache
\family default
) can be partitioned into a number of sets (
\family typewriter
CacheSet
\family default
s), the number of sets in a cache is defined by the parameter 
\family typewriter
numSets
\family default
.
 And each set can be partitioned further into a few blocks (
\family typewriter
CacheBlock
\family default
s), the number of blocks in a set is defined by the parameter 
\family typewriter
assoc
\family default
 (associativity).
 And the cache replacement policy tries to select a victim cache block within
 a set to evict when the requesting cache block is being brought from the
 lower cache hierarchy.
\end_layout

\begin_layout Paragraph
Directory.
\end_layout

\begin_layout Standard
Each cache maintains its own directory (
\family typewriter
Dir
\family default
) which is a set of directory entries (
\family typewriter
DirEntry
\family default
s).
 Each directory entry keeps the track of owner and sharer information for
 the associated cache block or subblock, depending on the availability of
 subblock modeling.
\end_layout

\begin_layout Subsubsection
Behavioral Modeling
\end_layout

\begin_layout Paragraph
Cache Coherence (Directory Based MESI as an Example).
\end_layout

\begin_layout Standard
A directory based MESI cache coherence protocol running on a simple fixed-latenc
y point-to-point interconnect is modeled for the moment.
 the cache block state transition diagram is shown in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Directory-based-MESI"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/itecgo/Flexim/code/flexim/doc/mesi_dir_cc_protocol.pdf
	scale 60
	BoundingBox 60bp 80bp 700bp 580bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Directory based MESI Cache Coherence
\begin_inset CommandInset label
LatexCommand label
name "fig:Directory-based-MESI"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
GUI-Based Integrated Simulation Environment
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
Based on the the language D's GTK binding (gtkd), a GUI-based integrated
 simulation environment (ISE) has been developed to make Flexim's users
 life easier.
 A typical use case of Flexim ISE is outlined as follow:
\end_layout

\begin_layout Enumerate
The user opens Flexim ISE, and draws some architectural blueprints on the
 canvas.
 Some common drawing tools such as texts, textboxes and arrows are provided
 in Flexim ISE.
\end_layout

\begin_layout Enumerate
The user select and assign the architectural simulation role to each desired
 blueprints.
 Blueprints themselves are not simulator configurations.
 Therefore, in order to make them simulatable, we need to assign them simulation
 roles.
 An overall architectural description is also needed to specify the target
 architecture requirements.
 For example, the ISE view of a shared L2 cache based dual core architecture
 is shown in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ISE-View-of"

\end_inset

, in which boxes with dotted borders represent functional simulation components,
 such as a fixed-latency P2P interconnect and a fixed-latency DRAM controller,
 and other boxes represent cycle-accurate simulation components, such as
 two out-of-order processor cores and various kinds of caches.
\end_layout

\begin_layout Enumerate
The user composes different workload configurations which are composed of
 benchmarks from preset popular benchmark suites, such as CPU2006, mst,
 MediaBench.
 Then assign a workload configuration to each hardware context or processor
 core based on whether simultaneous multithreading is enabled or not.
\end_layout

\begin_layout Enumerate
The user pushes the 
\begin_inset Quotes eld
\end_inset

start simulation
\begin_inset Quotes erd
\end_inset

 button to wait and see the simulation progress that updated periodically
 on the ISE's dynamic simulation view.
 You can now see the previously drawn architectural blueprints display their
 respective architectural state.
 The dynamic simulation view can be customized to your research needs.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/itecgo/Flexim/code/flexim/doc/ISE.pdf
	scale 35
	BoundingBox 0bp 0bp 1093bp 576bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Flexim Integrated Simulation Environment (ISE)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/itecgo/Flexim/code/flexim/doc/demo_arch.pdf
	scale 45
	BoundingBox 50bp 180bp 750bp 650bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ISE View of a Simulated Shared L2 Cache Based Dual Core
\begin_inset CommandInset label
LatexCommand label
name "fig:ISE-View-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Design and Implementation
\end_layout

\begin_layout Section
Simulation Results
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
In this paper, we have detailed the Flexim multicore simulator core and
 its GUI-based integrated simulation environment.
 
\end_layout

\begin_layout Section*
Acknowledgments
\end_layout

\begin_layout Standard
This work was supported by the Ministry of Education of China-Intel Special
 Research Foundation for Information Technology program under the contract
 No.
 MOE-INTEL-08-10.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/home/itecgo/research/refs_classfied/default"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
